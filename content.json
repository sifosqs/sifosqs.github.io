{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/10/10/hello-world/"},{"title":"java-String类","text":"","link":"/2021/10/11/java-String%E7%B1%BB/"},{"title":"java-面向对象","text":"多态多态：多态是同一个行为具有多个不同表现形式或形态的能力。 多态存在的单个必要条件 继承 重写 父类引用指向子类对象：Persion p = new Child() 贴一段代码来看一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Test { public static void main(String[] args) { Animal a1 = new Cat(); Animal a2 = new Dog(); show(a1); show(a2); Animal a = new Cat(); a.eat(); Cat c = (Cat) a; c.work(); } public static void show(Animal a){ a.eat(); //类型判断 if(a instanceof Cat){//猫做得事情 Cat c = (Cat) a; c.work(); } if (a instanceof Dog){//狗做得事情 Dog c = (Dog) a; c.work(); } }}abstract class Animal{ abstract void eat();}class Cat extends Animal{ public void eat() { System.out.println(&quot;吃鱼&quot;); } public void work(){ System.out.println(&quot;抓老鼠&quot;); }}class Dog extends Animal{ public void eat(){ System.out.println(&quot;吃骨头&quot;); } public void work(){ System.out.println(&quot;看家&quot;); }} 运行结果 123456吃鱼抓老鼠吃骨头看家吃鱼抓老鼠 抽象类抽象类：在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 由于抽象类不能实力化，所以抽象类必须被继承，才能被使用。 举个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243public abstract class Employee{ private String name; private String address; private int number; public Employee(String name, String address, int number) { System.out.println(&quot;Constructing an Employee&quot;); this.name = name; this.address = address; this.number = number; } public double computePay() { System.out.println(&quot;Inside Employee computePay&quot;); return 0.0; } public void mailCheck() { System.out.println(&quot;Mailing a check to &quot; + this.name + &quot; &quot; + this.address); } public String toString() { return name + &quot; &quot; + address + &quot; &quot; + number; } public String getName() { return name; } public String getAddress() { return address; } public void setAddress(String newAddress) { address = newAddress; } public int getNumber() { return number; }} 该类和普通的类没有区别，依然有3个变量，一个构造方法，7个成员方法，现在如下编译时，会产生错误， 1234567891011public class AbstractDemo{ public static void main(String [] args) { /* 以下是不允许的，会引发错误 */ Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43); System.out.println(&quot;\\n Call mailCheck using Employee reference--&quot;); e.mailCheck(); }} 报错： 1234Employee.java:46: Employee is abstract; cannot be instantiated Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43); ^1 error 所以通过继承Employee类，来使用Employee的属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Salary extends Employee{ private double salary; //Annual salary public Salary(String name, String address, int number, double salary) { super(name, address, number); setSalary(salary); } public void mailCheck() { System.out.println(&quot;Within mailCheck of Salary class &quot;); System.out.println(&quot;Mailing check to &quot; + getName() + &quot; with salary &quot; + salary); } public double getSalary() { return salary; } public void setSalary(double newSalary) { if(newSalary &gt;= 0.0) { salary = newSalary; } } public double computePay() { System.out.println(&quot;Computing salary pay for &quot; + getName()); return salary/52; }}public class AbstractDemo{ public static void main(String [] args) { Salary s = new Salary(&quot;Mohd Mohtashim&quot;, &quot;Ambehta, UP&quot;, 3, 3600.00); Employee e = new Salary(&quot;John Adams&quot;, &quot;Boston, MA&quot;, 2, 2400.00); System.out.println(&quot;Call mailCheck using Salary reference --&quot;); s.mailCheck(); System.out.println(&quot;\\n Call mailCheck using Employee reference--&quot;); e.mailCheck(); }} 编译结果如下： 123456789Constructing an EmployeeConstructing an EmployeeCall mailCheck using Salary reference --Within mailCheck of Salary classMailing check to Mohd Mohtashim with salary 3600.0Call mailCheck using Employee reference--Within mailCheck of Salary classMailing check to John Adams with salary 2400. 详设计一个类，该类有一个特别的成员方法，具体实现意由它的子类确定，那么可以在父类中声明该方法是抽象方法，抽象方法只有一个方法名，没有方法体。 1234567public abstract class Employee { private String name; private String address; private int number; public abstract double computePay(); //其他方法} 声明抽象方法会造成两个结果： 一个类包含抽象方法，该类一定是抽象类 任何子类必须重写父类的抽象方法，或者声明自身是抽象类，最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。 123456789101112public class Salary extends Employee{ private double salary; // Annual salary public double computePay() { System.out.println(&quot;Computing salary pay for &quot; + getName()); return salary/52; } //其余代码} 抽象类总结： 抽象类不嫩被实例化，只有继承抽象类的非抽象子类才可以实例化对象 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类 抽象类中的方法只是声明，没有方法体， 构造方法，类方法（用static修饰的方法） 不嫩声明为抽象方法 抽象类的子类必须给出抽象方法的具体实现，除非它也被声明为抽象类","link":"/2021/10/11/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"}],"categories":[]}