{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/10/10/hello-world/"},{"title":"java-String类","text":"","link":"/2021/10/11/java-String%E7%B1%BB/"},{"title":"java-常用工具类","text":"java 常用工具类 一、util包下的常用类1.Collections常用方法： 12345678910111213public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c,T... elements)将所有指定元素添加到指定 collection 中。public static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list,T key)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定。public static &lt;T&gt; int binarySearch(List&lt;? extends T&gt; list,T key,Comparator&lt;? super T&gt; c)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且集合也事先必须是按照c比较器规则进行排序过的，否则结果不确定。public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，而且支持自然排序public static &lt;T&gt; T max(Collection&lt;? extends T&gt; coll,Comparator&lt;? super T&gt; comp)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，按照比较器comp找出最大者public static void reverse(List&lt;?&gt; list)反转指定列表List中元素的顺序。public static void shuffle(List&lt;?&gt; list) List 集合元素进行随机排序，类似洗牌public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)根据元素的自然顺序对指定 List 集合元素按升序排序public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; c)根据指定的 Comparator 产生的顺序对 List 集合元素进行排序public static void swap(List&lt;?&gt; list,int i,int j)将指定 list 集合中的 i 处元素和 j 处元素进行交换public static int frequency(Collection&lt;?&gt; c,Object o)返回指定集合中指定元素的出现次数public static &lt;T&gt; void copy(List&lt;? super T&gt; dest,List&lt;? extends T&gt; src)将src中的内容复制到dest中public static &lt;T&gt; boolean replaceAll(List&lt;T&gt; list，T oldVal，T newVal)：使用新值替换 List 对象的所有旧值public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)：返回指定列表支持的同步（线程安全的）列表public static &lt;T&gt; List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)返回指定列表的不可修改视图 1.1Comparator比较器排序，简单就是说比较两个对象之间的大小，在java中有两种比较方式，一个是实现java.lang.Comparable的接口，一种是实现java.util.Comparator的接口。 123456public int Comparator(String o1,String o2):比较两个参数的顺序两个对象比较的结果：&lt; &gt; =升序比较：o1 &gt; o2(正数) o1 &lt; o2 (负数)降序比较：o2 &gt; o1 (正数) o2 &lt; o1(负数) Demo: 123456789101112131415public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;abc&quot;); list.add(&quot;bac&quot;); list.add(&quot;cab&quot;); list.add(&quot;shb&quot;); Collections.sort(list,new Comparator&lt;String&gt;(){ //按照第一个单词降序 @Override public int compare(String o1, String o2) { return o2.charAt(0)-o1.charAt(0); } }); System.out.println(&quot;降序后的list:&quot;+list); } 1.2Comparable 和 Comparator的区别 Comparable: ​ 强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compaetTo 方法被称为她的自然比较方法。 只能在类中实现 compareTo() 一次，不能经常修改类的代码实现自己想要的排序，实现此接口的对象列表（和数组）可以通过 Collection.sort （和 Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无序指定比较器。 Comparator: ​ 强行对某个对象进行整体排序。可以将 Comparator 传递给 sort 方法（如Collection.sort 或 Array.sort），从而允许在排序上实现精确控制。 还可以使用 Comparator 来控制某些数据结构（如有序 set 或有序的映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。 Demo: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//Student类public class Student implements Comparable&lt;Student&gt; { private String name; private Integer age; public Student() { } public Student(String name, Integer age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; } @Override public int compareTo(Student o) { return this.age-o.age; }}//Testpublic static void main(String[] args) { List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student(&quot;sqs&quot;,24)); list.add(new Student(&quot;huang&quot;,22)); list.add(new Student(&quot;shihao&quot;,25)); list.add(new Student(&quot;zui&quot;,23)); /** * 让学生按照年龄升序 */ Collections.sort(list);//要求该list中元素类型，必须让该元素的类实现comparable接口 for (Student student : list) { System.out.println(student.toString()); } }-- 或者 public static void main(String[] args) { List&lt;Student1&gt; list = new ArrayList&lt;&gt;(); list.add(new Student1(&quot;sqs&quot;,22)); list.add(new Student1(&quot;huang&quot;,22)); list.add(new Student1(&quot;shihao&quot;,25)); list.add(new Student1(&quot;zui&quot;,23)); /** * 让学生按照年龄升序 */ Collections.sort(list, new Comparator&lt;Student1&gt;() { @Override public int compare(Student1 o1, Student1 o2) { //年龄排序 int result = o1.getAge()- o2.getAge(); if (result ==0 ){ //年龄一样，按照姓名首字符 result = o1.getName().charAt(0)-o2.getName().charAt(0); } return result; } }); for (Student1 student : list) { System.out.println(student.toString()); } } 总结：对于自定义的类型排序时，想要调用Collections.sort()或者Arrays.sort()时，必须指定一个比较器 在当前类中实现comparable接口，重写compareTo()方法，在里面指定比较方式 在调用sort（）方法时，在第二个参数的位置 new Comparator()对象，然后重写compare()方法 2.Calendar1234567891011121314151617181920212223242526272829public static void main(String[] args) { //获得一个Calendar的对象，是抽象类，无法new Calendar c = Calendar.getInstance(); //赋值时年月日时分秒常用的6个值。月份下标是从0开始 System.out.println(&quot;年&quot;+c.get(Calendar.YEAR)); System.out.println(&quot;月&quot;+c.get(Calendar.MONTH)+1); System.out.println(&quot;日&quot;+c.get(Calendar.DATE)); System.out.println(&quot;日&quot;+c.get(Calendar.DAY_OF_MONTH)); System.out.println(&quot;时&quot;+c.get(Calendar.HOUR_OF_DAY)); System.out.println(&quot;时&quot;+c.get(Calendar.HOUR)); System.out.println(&quot;分&quot;+c.get(Calendar.MINUTE)); System.out.println(&quot;秒&quot;+c.get(Calendar.SECOND)); //设置某个日期，可以一次设置年月日时分秒，也可以分开设置 c.set(2021,9,14,18,00); System.out.println(c.getTime()); //分开设置 c.set(Calendar.YEAR, 2018); c.set(Calendar.MONTH, Calendar.FEBRUARY); c.set(Calendar.DAY_OF_MONTH, 15); c.set(Calendar.HOUR_OF_DAY, 23); c.set(Calendar.MINUTE, 59); c.set(Calendar.SECOND, 59); System.out.println(c.getTime()); System.out.println(&quot;------&quot;); c.set(2018,0,31,0,0); c.add(Calendar.MONTH,1); System.out.println(c.getTime()); } 输出： 123456789101112131415年2021月91日14日14时14时2分16秒28Thu Oct 14 18:00:28 CST 2021Thu Feb 15 23:59:59 CST 2018------Wed Feb 28 00:00:59 CST 2018Process finished with exit code 0 3.日期操作类3.1Date1234567891011121314public static void main(String[] args) { Date date = new Date(); /** * Date 里面的无参构造调用了System.currentTimeMillis()回去了当前的时间 * public Date() { * this(System.currentTimeMillis()); * } * public Date(long date) { * fastTime = date; * } * */ System.out.println(date); } 从Date的构造方法中可以看出，Date类只是对long类型的一种包装，所以Date中一定存在日期与long类型转换的方法： 将long转换成Date:public Date(Loong date) 将Date换成long :public long getTime() 1234Date date = new Date();long current = date.getTime();current += 864000* 1000;//10天毫秒System.out.println(new Date(current)); long 之中存的毫秒，而不是秒，程序执行的都是以毫秒的量级 3.2SimpleDateFormat 将日期格式化：public final String format(Date date) 将字符串转为日期：public Date parse(String source) 构造方法：public SimpleDateFormat( String pattern) 1234567public static void main(String[] args) { Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;); String format = sdf.format(date); System.out.println(format); } 将字符串转换成Date 123456public static void main(String[] args) throws ParseException { String birthday = &quot;1998-12-12 16:11:11.111&quot;; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;); Date date = sdf.parse(birthday); System.out.println(date); } 4.UUID1UUID.randomUUID() 二、","link":"/2021/10/13/java-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"title":"java-面向对象","text":"java 基础知识 多态多态：多态是同一个行为具有多个不同表现形式或形态的能力。 多态存在的单个必要条件 继承 重写 父类引用指向子类对象：Persion p = new Child() 贴一段代码来看一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Test { public static void main(String[] args) { Animal a1 = new Cat(); Animal a2 = new Dog(); show(a1); show(a2); Animal a = new Cat(); a.eat(); Cat c = (Cat) a; c.work(); } public static void show(Animal a){ a.eat(); //类型判断 if(a instanceof Cat){//猫做得事情 Cat c = (Cat) a; c.work(); } if (a instanceof Dog){//狗做得事情 Dog c = (Dog) a; c.work(); } }}abstract class Animal{ abstract void eat();}class Cat extends Animal{ public void eat() { System.out.println(&quot;吃鱼&quot;); } public void work(){ System.out.println(&quot;抓老鼠&quot;); }}class Dog extends Animal{ public void eat(){ System.out.println(&quot;吃骨头&quot;); } public void work(){ System.out.println(&quot;看家&quot;); }} 运行结果 123456吃鱼抓老鼠吃骨头看家吃鱼抓老鼠 抽象类抽象类：在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 由于抽象类不能实力化，所以抽象类必须被继承，才能被使用。 举个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243public abstract class Employee{ private String name; private String address; private int number; public Employee(String name, String address, int number) { System.out.println(&quot;Constructing an Employee&quot;); this.name = name; this.address = address; this.number = number; } public double computePay() { System.out.println(&quot;Inside Employee computePay&quot;); return 0.0; } public void mailCheck() { System.out.println(&quot;Mailing a check to &quot; + this.name + &quot; &quot; + this.address); } public String toString() { return name + &quot; &quot; + address + &quot; &quot; + number; } public String getName() { return name; } public String getAddress() { return address; } public void setAddress(String newAddress) { address = newAddress; } public int getNumber() { return number; }} 该类和普通的类没有区别，依然有3个变量，一个构造方法，7个成员方法，现在如下编译时，会产生错误， 1234567891011public class AbstractDemo{ public static void main(String [] args) { /* 以下是不允许的，会引发错误 */ Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43); System.out.println(&quot;\\n Call mailCheck using Employee reference--&quot;); e.mailCheck(); }} 报错： 1234Employee.java:46: Employee is abstract; cannot be instantiated Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43); ^1 error 所以通过继承Employee类，来使用Employee的属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Salary extends Employee{ private double salary; //Annual salary public Salary(String name, String address, int number, double salary) { super(name, address, number); setSalary(salary); } public void mailCheck() { System.out.println(&quot;Within mailCheck of Salary class &quot;); System.out.println(&quot;Mailing check to &quot; + getName() + &quot; with salary &quot; + salary); } public double getSalary() { return salary; } public void setSalary(double newSalary) { if(newSalary &gt;= 0.0) { salary = newSalary; } } public double computePay() { System.out.println(&quot;Computing salary pay for &quot; + getName()); return salary/52; }}public class AbstractDemo{ public static void main(String [] args) { Salary s = new Salary(&quot;Mohd Mohtashim&quot;, &quot;Ambehta, UP&quot;, 3, 3600.00); Employee e = new Salary(&quot;John Adams&quot;, &quot;Boston, MA&quot;, 2, 2400.00); System.out.println(&quot;Call mailCheck using Salary reference --&quot;); s.mailCheck(); System.out.println(&quot;\\n Call mailCheck using Employee reference--&quot;); e.mailCheck(); }} 编译结果如下： 123456789Constructing an EmployeeConstructing an EmployeeCall mailCheck using Salary reference --Within mailCheck of Salary classMailing check to Mohd Mohtashim with salary 3600.0Call mailCheck using Employee reference--Within mailCheck of Salary classMailing check to John Adams with salary 2400. 详设计一个类，该类有一个特别的成员方法，具体实现意由它的子类确定，那么可以在父类中声明该方法是抽象方法，抽象方法只有一个方法名，没有方法体。 1234567public abstract class Employee { private String name; private String address; private int number; public abstract double computePay(); //其他方法} 声明抽象方法会造成两个结果： 一个类包含抽象方法，该类一定是抽象类 任何子类必须重写父类的抽象方法，或者声明自身是抽象类，最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。 123456789101112public class Salary extends Employee{ private double salary; // Annual salary public double computePay() { System.out.println(&quot;Computing salary pay for &quot; + getName()); return salary/52; } //其余代码} 抽象类总结： 抽象类不嫩被实例化，只有继承抽象类的非抽象子类才可以实例化对象 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类 抽象类中的方法只是声明，没有方法体， 构造方法，类方法（用static修饰的方法） 不嫩声明为抽象方法 抽象类的子类必须给出抽象方法的具体实现，除非它也被声明为抽象类 接口接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。 接口和类的区别： 接口不能用于实例化对象 接口没有构造方法 接口中所有的方法必须是抽象方法 接口中不能包含成员变量，除了static和finally声明的成员变量 接口和抽象类的区别： 抽象类中可以有方法体，，接口不行 抽象类中的方法可以是任何类型的，接口只能是static和finall 接口以下特性： 接口是隐式抽象的，当声明一个接口时，不必使用abstract 接口中的方法也是隐式抽象的，不必使用abstract 接口中的方法都是public的","link":"/2021/10/11/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"paperHelper插件","text":"","link":"/2021/10/14/paperHelper%E6%8F%92%E4%BB%B6/"},{"title":"redis命令","text":"redis的简单命令 1. Redis： 简介：Redis是一种数据库。能够存储数据。管理数据的一种软件。 Redis的数据大部分时间是存储在内存的，适合存储频繁访问，数据量比较小的数据。 2.Redis的特点 支持数据持久化 支持多种数据结构 不仅支持kay-value类型的数据，同时 还提供list，set，zset，hash 支持数据备份 支持master-slave模式的数据备份 3.Windows安装Redis 下载安装包 https://github.com/dmajkic/redis/releases 解压到环境文件夹中 开启Redis 使用Redis客户端来连接Redis 记住一句话，Windows下使用确实简单，但是Redis推荐使用Linux去开发 4.Linux安装 将安装包传到Linux上 解压Redis到/opt目录 tar -zxvf redis-5.0.12.tar.gz -C /opt 编译Redis，进入解压目录，并且执行make命令： 会报错 ，没有cc命令 则需要安装gcc 就需要使用yum进行安装，执行命令；yum -y install gcc 执行 gcc - v查看Linux的内核版本 再次回到Redis目录执行make命令 还会报错，因为第一次编译的文件有些会存在，第二次编译就会报错，所以要进行清理工作 make distclean 然后执行make install 来安装Redis 后台启动Redis：usr/local/bin redis-server 启动Redis服务： 前台启动：在任何目录下执行 redis-server 后台启动：在任何目录下执行 redis-server &amp;(没改配置文件) 启动Redis服务时：指定配置文件： redis-server redis.conf &amp;(改配置文件) 关闭Redis服务： 通过kill来关闭（暴力不推荐,容易丢失数据） ps -ef|grep redis查看pid kill -9 pid 通过Redis命令关闭 redis-cli shutdown redis的客户端：通过网络连接到redis服务器，从而实现redis服务器的交互，向服务端发送命令，并且显示redis服务处理结果。 redis-cli:是redis自带客户端，使用命令redis-cli就可以启动redis的客户端程序。 redis-cli:默认连接本机（127.0.0.1）上的6379端口上的redis服务 redis-cli -p 端口号：连接127.0.0.1（本机）指定端口上的服务 redis-cli -h ip地址 -p 端口号：连接指定主机上的指定端口的redis服务 退出客户端：在客户端执行命令：exit或者quit 5.redis的基本知识： 测试redis服务的性能：src里在任何目录下redis-benchmark （了解） 查看redis服务是否正常运行： ping 如果正常——pong 查看redi服务器s的统计信息：info info 查看redis所有的统计信息 info [信息段]：查看redis服务器 指定的统计信息，如：info replication：查看集群 redis默认使用16个库（==理解==） redis中的数据库实例只能有redis服务来创建和维护，开发人员不能修改和自行创建数据库实例；默认情况下，redis会自动创建16个数据库实例，并且给16个数据库进行编号，从0开始到15，使用时，通过编号来使用数据库；可以通过配置文件来制定redis自动创建数据库的个数；每一个数据库实例，本身占用的存储空间是很少的，所以也不会造成存储及空间的太多浪费 默认情况下，redis客户端连接的是编号位0的数据库实例； 使用select index 来切换数据库 查看数据库中key的数目：dbsize 查看当前数据库到底有哪些k:**keys *** 清空数据库实例：flushdb 清空所有数据库实例：flushall 查看redis中所有的配置信息：**config get *** 查看redis中指定的配置信息：config get parameter 清屏；clear 6.redis的5种数据结构redis是用来存储数据的，程序处理完的数据要存储到redis数据库中，不同特点的数据要存储在redis中不同类型的数据结构中。 字符串： list列表（有序，可重复） set集合（无序，不可重复） zset:必须后面跟着一个数，来排序，没有数就不要用这个结构 hash 7.redis常用的操作命令：string：单key:单value list：单key：多有序value：contacts：a,c,v, set:单key:多无序value：city:bj,sh,tj hash 单key：对象（属性：值）： student：id:1001,name:张三,age:20(k:v) zset 单key：多有序value： city:2000 bj,1500 sh ,1000 tj, 1200 cq(有个参照标准，升序排) 有序指的是排序 Redis中关于key的操作 123456789101112131415keys: 1.keys *,所有匹配0个或者多个字符 2.keys k*:以k开头 3.keys [jdsfsjf]hello:在[]里面匹配一个字符 4.keys k?d:匹配一个字符del :删除 del key || del k1 k2:返回删除的个数rename key :对key重命名dbsize:数据库中元素个数ttl key:查看某个key的生命周期expire key seconds: 设置key的生命周期select index :切换数据库type key :查看key的类型config get *: 查看配置exists key :key 是否存在，返回1/0 String 12345678910111213141516171819202122232425append key value :最佳字符串 ，返回的是追加后的长度strlen key :长度incr key :+1 ,若key不存在，设置一个key值，初始化为0decr key incrby key offset getrange key startIndex endIndex:获取字符串key中start，end的子字符 闭区间 可以为负的，从右到左setrange key offset value :放值setex key seconds value :设置值得同时最大生存周期（秒）setnx key value :解决了set key value ,覆盖了之前的数据，若存在，不设值，不存在，随便mset k v k v k v k v k v:批量设值mget k1 k2 k3:批量获取msetnx k v k v k v k v：当所有key都不存在时，才会设置成功，只要有一个就设置失败ttl：查看有效期psetex:毫秒在redis中字符串都是以二进制的方式来存储的BIT:SET K1 a a 对应的ASCII97 转为2进制为01100001 bit的相关命令就是对二进制进行操作的getbit k对应的value在offset处的value值 例如 set k1 agetbit k1 0 ----&gt;0getbit k1 1 ----&gt;1getbit k1 2 ----&gt;1getbit k1 3 ----&gt;0setbit :修改key 对应的value在offset处的值bitcount: 统计二进制中1的个数 list 12345678lpush key value value:将一个或者多个值插入列表的表头（往左侧放）lrange key start end :获取指定列表中的指定下标区间的元素 rpush list01 2 3 :将一个或者多个值插入列表的表头（往右侧放）lpop key :从指定列表中移除（表头）元素并返回表头元素lindex:返回列表中，下标为index的元素ltrim:集合截取blpop:阻塞式的弹出，相当于lpop的阻塞版 set 1234567891011121314sadd: 添加元素到一个key中smembers:获取一个key下的所有元素srem;移除指定的元素sismember:返回一个元素是否在集合中scard:返回集合的数量srandmember：随机返回集合里的元素spop:随机返回并且出栈一个元素smove：把一个元素从一个集合一道另一个集合中sdiff:返回两个集合的差集(以第一个为准，看第一个元素少啥)sinter:两个集合的交际 sdiffstore: 这个类似于sdiff，不同的是，计算出来的结果会保存在一个新的集合中SDIFFSTORE k3 k1 k2sinterstore :将计算出来的结果保存在一个新的集合中sunion:求并集 hash() student：id:1001,name:张三,age:20** 在hash中key是一个字符串，value是一个k:v键值对 123456789101112131415hset：添加值hget： 获取值hmset :批量设置值hmget :批量获取值hdel:删除指定的filed(value中的value值)hsetnx :默认情况下，可以和filed相同，会覆盖掉已有的value，hsetnx不会hvals:获取所有的valuehkeys :获取所有的keyhgetall :同时获取key和valuehexists:返回filed是否存在hincrby:给指定的value 自增1hincrbyfloat:hdecrby:hlen:返回某个key中的value的数量 hstrlen：返回某个key中的某一个filed的字符串长度 zset 1234567891011121314151617zadd:将指定的元素添加到有有序集合中zscore:返回member的scope值zrange:返回集合中的一组元素zrange k1 0 3 withscores: 返回一组元素(带值)zrevrange:返回一组元素，倒序 zcard:元素个数zcount:返回score在某个区间内的元素的个数zcount k1 60 90 闭区间zcount k1 (60 (90 开区间zrangebyscore:按照score的范围返回元素zrank:返回members的排名zrank k1 v1(从小到大)zrevrank k1 v1：(从大到小)zincrby:score 自增zinterscore:取交集，放到信集合里zrem:弹出一个元素zlexcount:计算members的数量 zrangebylex:返回指定区间内的成员 key 1234567del:删除一个k:vdump:序列化给定的key exists k: 判断k是否存在ttl:查看k的有效期 -1 永不过期， -2 已经过期， 其他是是有效期 expire ：给k设置有效期,如果在k过期之前被重新set了，则过期时间失效 persist:移除k的过期时间pttl:返回的是ms 补充 12五种数据类型，在第一次使用的时候，如果容器不存在，会自动创建一个 如果里面没有元素了，那么立即删除容器，释放内存 8.Redis 的 java客户端1.开启远程连接123456Redis默认是不支持远程连接的，需要手动开启修改两个地方1.绑定主机注释掉好像得需要把保护模式变成no2.开启密码校验改完之后 启动redis 2.Jedis2.1连接测试 创建一个普通的maven项目 添加jedis依赖 1234567&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt; 创建一个测试方法 1234567//1.构造jedis对象 Jedis jedis = new Jedis(&quot;192.168.5.131&quot;,6379); //2. 密码认证 jedis.auth(&quot;sqs102428&quot;); //测试是否连接成功 String ping = jedis.ping(); System.out.println(ping); 对于jedis而言，连接上redis就很简单， 在jedis中，方法的API和redis的命令高度一致由于 2.2连接池在实际应用中，jedis实例一般是从连接池中获取的，由于jedis是线程不安全的，所以在使用的时候，从连接池中取，用完还给连接池 1234567891011121314public class JedisPoolTest { public static void main(String[] args) { //1.构造连接池 JedisPool pool = new JedisPool(&quot;192.168.5.131&quot;,6379); //2.从连接池中获取jedis连接 Jedis jedis = pool.getResource(); jedis.auth(&quot;sqs102428&quot;); //3.jedis操作 String ping = jedis.ping(); System.out.println(ping); //4.归还连接 jedis.close(); }} 第三步抛出异常的话，会导致第四步无法归还，所以对代码改进， 12345678910111213141516171819public class JedisPoolTest { public static void main(String[] args) { //1.构造连接池 JedisPool pool = new JedisPool(&quot;192.168.5.131&quot;,6379); //2.从连接池中获取jedis连接 Jedis jedis = pool.getResource(); jedis.auth(&quot;sqs102428&quot;); //3.jedis操作 try{ String ping = jedis.ping(); System.out.println(ping); }catch (Exception e){ e.printStackTrace(); }finally { //4.归还连接 if (jedis != null) { jedis.close(); } } 利用jdk1.7的特性，try-with-resource,对代码改造 123456JedisPool pool = new JedisPool(&quot;192.168.5.131&quot;, 6379); try(Jedis jedis = pool.getResource()){ String ping = jedis.ping(); System.out.println(ping); } 进一步改进 12345678910111213141516171819202122232425262728293031323334public interface CallWithReedis { void call(Jedis jedis);}public class Redis { private JedisPool pool; public Redis() { GenericObjectPoolConfig config = new GenericObjectPoolConfig(); //连接池最大空闲数 config.setMaxIdle(300); //最大连接数 config.setMaxTotal(1000); //连接最大等待时间 config.setMaxWaitMillis(3000); //在空闲时检查有效性 config.setTestOnBorrow(true); pool = new JedisPool(config,&quot;192.168.5.131&quot;,6379,3000,&quot;sqs102428&quot;); } public void excute(CallWithRedis callWithRedis){ try(Jedis jedis = pool.getResource()){ callWithRedis.call(jedis); } }}public class JedisPoolTest { public static void main(String[] args) { Redis redis = new Redis(); redis.excute(jedis -&gt; { jedis.auth(&quot;sqs102428&quot;); System.out.println(jedis.ping()); }); }} 3.Lettuce","link":"/2021/10/30/redis%E5%91%BD%E4%BB%A4/"},{"title":"spring5","text":"spring5框架基础知识 1.Spring框架介绍2.IOC容器2.1IOC底层原理2.2IOC接口（BeanFactory）2.3IOC操作Bean管理（基于xml）2.4IOC操作Bean管理（基于注解）3.AOP4.JdbcTemplate5.事务管理6.Spring5新特性","link":"/2021/10/27/spring5/"},{"title":"springboot缓存","text":"springboot简单实现缓存 一、springboot + redis 加入两个依赖 cache redis application.properties 连接redis： 123spring.redis.host=redis的服务器IPspring.redis.password=密码spring.redis.port=6379 在启动类上加@EnableCache：开启缓存功能 4个注解 @Cacheable 1.@Cacheable(cacheNames = “c1”) :注解标注在方法上，表示该方法的返回值需要放到缓中 2.默认情况下，缓存的key是方法的参数 @EnableCaching:开启缓存功能 @CachePut:更新缓存 @CachePut(cacheNames= “c1”,key=“#user.id”) public User updateUser(User user){ ​ return user; } @CacheEvict:删除缓存 Demo1 1234567891011121314151617181920212223242526272829//User类//加入缓存，实现serializable 接口public class User implements Serializable { private String username; private Long id; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } @Override public String toString() { return &quot;User{&quot; + &quot;username='&quot; + username + '\\'' + &quot;, id=&quot; + id + '}'; } Service 类： 1234567891011public class UserService { @Cacheable(cacheNames = &quot;c1&quot;)//标记在方法上，表示该方法的返回值存到缓存中 //默认情况下，方法的参数作为缓存的key public User getUserByUserId(Long id){ System.out.println(&quot;getUserByUserId:&quot;+id); User user = new User(); user.setId(id); user.setName(&quot;sqs&quot;); return user; }} 测试结果： 123456789101112@Testvoid contextLoads(){ for(int i=0;i&lt;3;i++){ User u = userService.getUserById(98L); System.out.println(&quot;u=&quot;+u); }}输出结果：getUserById:98u=User{username='sqs',id=98}u=User{username='sqs',id=98}u=User{username='sqs',id=98} redis里面的存储情况： Demo2 12345678910111213141516171819202122232425//多个参数时，key的值是什么 /** * 默认情况下，方法的参数将作为缓存的key * 方法存在对个参数，则默认情况下，多个参数共同作为缓存的key * 1.通过key=“#参数名” 来指定缓存key * 2.也可以使用SPEL的表达式 * * @param id * @param username * @return */public User getUserById2(Long id,String name){ User user = new User(); user.setId(id); user.setName(name); return user;} @Testvoid contextLoads(){ User u1 = userService.getUserById2(99L,&quot;zhangsan&quot;); User u2 = userService.getUserById2(99L,&quot;zhangsan&quot;);}输出：getUserById2:99 //执行一次 默认情况下，方法的参数将作为缓存的key 方法存在对个参数，则默认情况下，多个参数共同作为缓存的key1.通过key=“#参数名” 来指定缓存key2.也可以使用SPEL的表达式 第一种方式指定key： 123456789101112指定key：# + 参数名， 只要id一样，那就可以从缓存中取@Cacheable(cacheNames = &quot;c2&quot;,key = &quot;#id&quot;) public User getUserById2(Long id,String name){}@Testvoid contextLoads(){ User u1 = userService.getUserById2(99L,&quot;zhangsan&quot;); User u2 = userService.getUserById2(99L,&quot;lisi&quot;);}输出结果： 代码没有错，getUserById2:99User{username='zhangsan', id=99} 逻辑有错误 第二种方式指定key：使用spel表达式 12345678@Cacheable(cacheNames = &quot;c2&quot;,key = &quot;#root.method.name&quot;) public User getUserById2(Long id,String name){}@Testvoid contextLoads(){ User u1 = userService.getUserById2(99L,&quot;zhangsan&quot;); User u2 = userService.getUserById2(99L,&quot;lisi&quot;);} 第三种指定key的方式：完全指定key 1234567891011//创建一个MyKeyGenerator类@Componentpublic class MyKeyGenerator implements KeyGenerator { @Override public Object generate(Object target, Method method, Object... params) { String s = target.toString() + &quot;:&quot; + method.getName() + &quot;:&quot; + Arrays.toString(params); return s; }} @Cacheable(cacheNames = &quot;c2&quot;,keyGenerator = &quot;myKeyGenerator&quot;)public User getUserById2(Long id,String name){} Demo3:缓存的更新 12345678910111213141516@CachePut(cacheNames = &quot;c1&quot;,key = &quot;#user.id&quot;)public User updateUser(User user){ return user}@Testvoid contextLoads(){ User u1 = userService.getUserById(100L); u1.setName(&quot;wangwu&quot;); userService.updateUser(u1); User u2 = userService. getUserById(100L); System.out.println(u2)}输出：getUserById:100User{username='wangwu', id=100} Demo4:删除缓存：默认先删除数据库，在删除缓存 ,beforeInvocation =true,是先删除缓存，后删库 12345678910111213141516@CacheEvict(cacheNames = &quot;c1&quot;,key=&quot;#id&quot;)public void deleteUserById(Long id){ sout(&quot;deleteUserById：&quot; + id);}@Testvoid contextLoads5(){ //上一步缓存中有user={id:100,username:wangwu} userService.deleteUserByTd(100L); User u = userService.getUserById(100L); System.out.println(u); }输出：deleteUserByTdgetUserById:100User{username='sqs', id=100} 二、springboot+ehcache","link":"/2021/10/15/springboot%E7%BC%93%E5%AD%98/"},{"title":"sql语句练习","text":"SQL语句练习，习题来源于网络，SQL语句有部分参考。 表名和字段–1.学生表Student(s_id,s_name,s_birth,s_sex) –学生编号,学生姓名, 出生年月,学生性别–2.课程表Course(c_id,c_name,t_id) – –课程编号, 课程名称, 教师编号–3.教师表Teacher(t_id,t_name) –教师编号,教师姓名–4.成绩表Score(s_id,c_id,s_score) –学生编号,课程编号,分数 测试数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768--建表--学生表CREATE TABLE `Student`( `s_id` VARCHAR(20), `s_name` VARCHAR(20) NOT NULL DEFAULT '', `s_birth` VARCHAR(20) NOT NULL DEFAULT '', `s_sex` VARCHAR(10) NOT NULL DEFAULT '', PRIMARY KEY(`s_id`));--课程表CREATE TABLE `Course`( `c_id` VARCHAR(20), `c_name` VARCHAR(20) NOT NULL DEFAULT '', `t_id` VARCHAR(20) NOT NULL, PRIMARY KEY(`c_id`));--教师表CREATE TABLE `Teacher`( `t_id` VARCHAR(20), `t_name` VARCHAR(20) NOT NULL DEFAULT '', PRIMARY KEY(`t_id`));--成绩表CREATE TABLE `Score`( `s_id` VARCHAR(20), `c_id` VARCHAR(20), `s_score` INT(3), PRIMARY KEY(`s_id`,`c_id`));--插入学生表测试数据insert into Student values('01' , '赵雷' , '1990-01-01' , '男');insert into Student values('02' , '钱电' , '1990-12-21' , '男');insert into Student values('03' , '孙风' , '1990-05-20' , '男');insert into Student values('04' , '李云' , '1990-08-06' , '男');insert into Student values('05' , '周梅' , '1991-12-01' , '女');insert into Student values('06' , '吴兰' , '1992-03-01' , '女');insert into Student values('07' , '郑竹' , '1989-07-01' , '女');insert into Student values('08' , '王菊' , '1990-01-20' , '女');--课程表测试数据insert into Course values('01' , '语文' , '02');insert into Course values('02' , '数学' , '01');insert into Course values('03' , '英语' , '03');--教师表测试数据insert into Teacher values('01' , '张三');insert into Teacher values('02' , '李四');insert into Teacher values('03' , '王五');--成绩表测试数据insert into Score values('01' , '01' , 80);insert into Score values('01' , '02' , 90);insert into Score values('01' , '03' , 99);insert into Score values('02' , '01' , 70);insert into Score values('02' , '02' , 60);insert into Score values('02' , '03' , 80);insert into Score values('03' , '01' , 80);insert into Score values('03' , '02' , 80);insert into Score values('03' , '03' , 80);insert into Score values('04' , '01' , 50);insert into Score values('04' , '02' , 30);insert into Score values('04' , '03' , 20);insert into Score values('05' , '01' , 76);insert into Score values('05' , '02' , 87);insert into Score values('06' , '01' , 31);insert into Score values('06' , '03' , 34);insert into Score values('07' , '02' , 89);insert into Score values('07' , '03' , 98); 练习题和SQL语句123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242SELECT s.*, a.`s_score` AS 01score, b.`s_score` AS 02score FROM Student s INNER JOIN Score a ON s.`s_id` = a.`s_id` AND a.`c_id` = '01' INNER JOIN Score b ON s.`s_id` = b.`s_id` AND b.`c_id` = '02' WHERE a.`s_score` &gt; b.`s_score` -- 或者SELECT s.*, a.`s_score` AS 01score, b.`s_score` AS 02score FROM student s, score a, Score b WHERE s.s_id = a.s_id AND a.c_id = '01' AND s.s_id = b.s_id AND b.c_id = '02' AND a.s_score &gt; b.s_score -- 2、查询&quot;01&quot;课程比&quot;02&quot;课程成绩低的学生的信息及课程分数-- 3、查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩SELECT s.`s_id`, s.`s_name`, ROUND(AVG(a.`s_score`),2) AS avg_score FROM Student s INNER JOIN Score a ON s.`s_id` = a.`s_id` GROUP BY s.`s_id` HAVING AVG(a.`s_score`) &gt;= 60 -- 或者SELECT s.`s_id`, s.`s_name`, ROUND(AVG(a.`s_score`),2) AS avg_score FROM Student s, Score a WHERE s.`s_id` = a.`s_id` GROUP BY s.`s_id`HAVING AVG(a.`s_score`) &gt;= 60 -- 4、查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩 -- (包括有成绩的和无成绩的)SELECT s.`s_id`, s.`s_name`, ROUND(AVG(a.`s_score`),2) AS avg_score FROM Student s INNER JOIN Score a ON s.`s_id` = a.`s_id` GROUP BY s.`s_id` HAVING AVG(a.`s_score`) &gt;= 60 UNIONSELECT s.`s_id`, s.`s_name`, 0 AS avg_score FROM Student s WHERE s.`s_id` NOT IN(SELECT DISTINCT `s_id`FROM Score)-- 5、查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩SELECT a.`s_id` AS 编号, s.`s_name` AS 名字, COUNT(a.`c_id`) AS 选课总数, SUM(a.`s_score`) AS 总成绩 FROM Score a INNER JOIN Student s ON s.`s_id` = a.`s_id` GROUP BY a.`s_id` UNIONSELECT s.`s_id` AS 编号, s.`s_name` AS 名字, 0 AS 选课总数, 0 AS 总成绩 FROM Student sWHERE s.`s_id` NOT IN (SELECT DISTINCT a.`s_id`FROM Score a)SELECT s.`s_id` AS 编号, s.`s_name` AS 名字, COUNT(a.`c_id`) AS 选课总数, SUM(a.`s_score`) AS 总成绩 FROM Student s LEFT JOIN Score a ON s.`s_id` = a.`s_id` GROUP BY s.`s_id`-- 6、查询&quot;李&quot;姓老师的数量 SELECT COUNT(t.t_id) FROM Teacher t WHERE t.t_name LIKE '李%' -- 7、查询学过&quot;张三&quot;老师授课的同学的信息 SELECT s.* FROM Student s, Score a WHERE s.`s_id` = a.`s_id` AND a.`c_id` = (SELECT c.c_id FROM Teacher t, course c WHERE t.t_id = c.t_id AND t.t_name = '张三')-- 8、查询没学过&quot;张三&quot;老师授课的同学的信息 SELECT s.* FROMStudent sWHERE s.`s_id` NOT IN(SELECT s.`s_id` FROM Student s, Score a WHERE s.`s_id` = a.`s_id` AND a.`c_id` = (SELECT c.c_id FROM Teacher t, course c WHERE t.t_id = c.t_id AND t.t_name = '张三'))-- 9、查询学过编号为&quot;01&quot;并且也学过编号为&quot;02&quot;的课程的同学的信息SELECT s.* FROM Student s INNER JOIN Score a ON s.`s_id` = a.`s_id` AND a.`c_id` = '01' INNER JOIN Score b ON s.`s_id` = b.`s_id` AND b.`c_id` = '02' -- 10、查询学过编号为&quot;01&quot;但是没有学过编号为&quot;02&quot;的课程的同学的信息SELECT DISTINCT s.* FROM Student s INNER JOIN Score a ON s.`s_id` = a.`s_id` AND a.`c_id` = '01' INNER JOIN Score b ON s.`s_id` = b.`s_id` AND s.`s_id` NOT IN (SELECT DISTINCT s.`s_id` FROM Student s, Score a WHERE s.`s_id` = a.`s_id` AND a.`c_id` = '02')SELECT s.* FROM Student s WHERE s.`s_id` IN (SELECT a.`s_id` FROM Score a WHERE a.`c_id` = '01') AND s.`s_id` NOT IN (SELECT b.`s_id` FROM Score b WHERE b.`c_id` = '02')-- 12、查询至少有一门课与学号为&quot;01&quot;的同学所学相同的同学的信息 SELECT s.* FROM Student s WHERE s.`s_id` IN (SELECT DISTINCT a.`s_id` FROM Score a WHERE a.`c_id` IN (SELECT a.`c_id` FROM Score a WHERE a.`s_id` = '01'))-- 13、查询和&quot;01&quot;号的同学学习的课程完全相同的其他同学的信息SELECT s.* FROM score sc,student sWHERE s.`s_id` = sc.`s_id` AND s.`s_id`!='01' AND sc.s_id NOT IN(SELECT sc.s_id FROM score sc WHERE sc.c_idNOT IN(SELECT sc.c_id FROMscore sc WHERE sc.s_id = '01'))GROUP BY s.s_idHAVING COUNT(*) = (SELECT COUNT(c_id)FROM score WHERE s_id = '01')-- 1.查1号同学的课-- 2.查1号同学选的课以外的同学-- 3.把2的同学去除掉-- 4.用数量筛选一次-- 15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩SELECT s.s_id,s.`s_name`,ROUND(AVG(sc.`s_score`),2) FROMscore sc ,student sWHERE sc.s_score &lt;=60 AND s.s_id = sc.`s_id`GROUP BY s.`s_id`HAVING COUNT(s.`s_id`)&gt;=2-- 16、检索&quot;01&quot;课程分数小于60，按分数降序排列的学生信息SELECT s.*,sc.`c_id`,sc.`s_score`FROM score sc,student sWHERE sc.`c_id` = '01' AND sc.`s_score`&lt;=60 AND sc.`s_id` = s.`s_id`ORDER BY sc.`s_score` DESC","link":"/2021/10/12/sql%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/"},{"title":"vue基础知识","text":"vue 基础知识 vue-组件 父组件可以使用props把数据传给子组件 子组件可以使用$emit触发父组件的自定义方法 在vue中，使用props向子组件传值 子组件部分： 12345678910Vue.component('javaboy',{ data(){ return{ counter:0 } }, props:['title'], temoplate:'&lt;div&gt;&lt;button @click=&quot;counter++&quot;&gt;hello{{counter}} &lt;/button&gt;&lt;div&gt;{{title}} &lt;/div&gt;&lt;/div&gt;'}) 如果需要从父组件中获取台title的值，就需要使用props:[‘title’],在 props 中添加了元素之后，就不需要在 data 中再添加变量了. 父组件部分： 1234&lt;div&gt; &lt;javaboy :title=&quot;组件一&quot;&gt;&lt;/javaboy&gt; &lt;javaboy :title=&quot;组件二&quot;&gt;&lt;/javaboy&gt;&lt;/div&gt; 在调用组件的时候，使用v-bind 将 title的值要绑定data里面的变量，这里就直接赋值了，然后就可以将父组件的值传递给子组件了。 props是一个数组： 子组件： 1234567Vue.component('blog',{ props:['title','date','author'], template:'&lt;div&gt; &lt;div&gt;{{title}}&lt;/div&gt; &lt;div&gt;{{date}}--------{{author}}&lt;/div&gt; &lt;/div&gt;'}) 父组件： 123456789101112131415161718192021222324&lt;div&gt; &lt;blog v-for=&quot;(blog,index) in blogs :key=&quot;index&quot; :title=&quot;blog.title&quot; :date=&quot;blog.date&quot; :author=&quot;blog.author&quot; &quot;&gt;&lt;/blog&gt;&lt;/div&gt;data:{ blogs:[ { title:'标题一', date:'数据一', author:'作者一' }, { title:'标题二', date:'数据二', author:'作者二' }, { title:'标题三', date:'数据三', author:'作者三' },]} 子组件向父组件传值：主要是通过时间传递给父组件 子组件： 1234567891011121314&lt;template&gt; &lt;div class=&quot;sqs&quot;&gt; &lt;button @click=&quot;select(&quot;大连&quot;)&quot;&gt;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;methods:{ select(val){ let data = { cityName:val } this.$emit('showCityNmae',data)//select时间触发后，自动触发showCityNmae时间 }} 父组件： 12345678910&lt;div&gt; &lt;sqs @showCityNmae=&quot;updateCity&quot;&gt;&lt;/sqs&gt;&lt;/div&gt;methods:{ updateCity(data){//触发子组件城市选择-选择城市的事件 this.city = data.cityName//改变了父组件的值 console.log(city) }}","link":"/2021/10/12/vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"spring5","slug":"spring5","link":"/tags/spring5/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"vue","slug":"vue","link":"/tags/vue/"}],"categories":[]}