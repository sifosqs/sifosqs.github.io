{"pages":[],"posts":[{"title":"Git","text":"git的命令操作： 1234567891011git add .添加所有文件到暂存区git status 查看文件状态git commit -m &quot;&quot;提交暂存区的内容到本地放库 -m 提交信息git branch : 列出所有分支git branch -r:远程所有的分支git branch dev :新建dev分支,但依然停留在当前分支git checkout -b [branch] 新建一个分支，并切换到该分支git merge [branch] 合并指定分支到当前分支git branch -d [branch-name]删除分支git push origin --delete [branch-name]git branch -dr [remote/branch]","link":"/2021/10/30/Git/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/10/10/hello-world/"},{"title":"io流","text":"io流 io流分流方式： 按照内存：输入输出 读取数据方式： 字节流：一次读8个字节，这个流是==万能==的，什么类型的文件都可以读取，文本文件，图片，声音，视频文件 字符流：一次读取一个字符，方便读取普通文本而存在的，只能读取纯文本，Word也读不了（里面有格式） Java中的io流已经写好了，我么主要掌握那些流，特点，常用方法、 io流的四大家族：inputstream 字节输入 outstream 字节输出 reader 字符输入 writer 字符输出 stream 结尾的是字节流 reader /writer 是字符流 所有的流都实现了closeable接口，都是可关闭的，都有close（）方法 所有的输出流都实现了flushable接口，都是可刷新的flush方法 ==java.io包下需要掌握16个流== ​ 文件专属： FileInputerStream FileOutputerStream FileReader FileWriter 转换流 InputStreamReader OutputStreamWriter 缓冲流专属： BufferedReader BufferedWriter BufferedInputerStream BufferedOutputerStream 数据流专属： DataInputerStream DataOutputerStream 标准输出流 PrinterWriter PrinterStream 对象专属流 ObjectInputerStream ObjectOutputerStream 1.File1.1FileInputStream12345678910111213141516171819/*FileInputerStream 1.文件输入流，万能的 2.字节的方式，完成输入的操作，完成读的操作（硬盘---&gt;内存） */=================================================/*对第一个程序进行改进分析 这个程序的缺点： 一次读取一个字节，这样内存和硬盘交互太频繁，基本上时间/资源都浪费在交互上了，能不能一次读取多个字节呢 */ ================================================ /*int read(byte[] b) 一次读取b。length个字节 减少硬盘和内存的交互，提高程序的执行效率 往byte数组中读 */ 12345678910111213141516171819202122232425262728293031323334353637383940package sen.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;/*最终版 */public class FileInputerStreamDemo04 { public static void main(String[] args) { FileInputStream stream =null; try { stream = new FileInputStream(&quot;src/tempfile2&quot;); byte[] bytes=new byte[4]; //int read = stream.read(bytes);// while (read==4){// System.out.print(new String(bytes,0,read));// read = stream.read(bytes);// }// System.out.print(new String(bytes,0,read)); int read=0; while ((read = stream.read(bytes))!=-1){ System.out.println(new String(bytes,0,read)); } } catch (IOException e) { e.printStackTrace(); }finally { if (stream != null) { try { stream.close(); } catch (IOException e) { e.printStackTrace(); } } } }} 1.1.1available()方法12345678910111213141516171819202122232425262728293031323334353637package sen.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;/*FileInputerStream其他的方法 int available（）：返回流中没有读到的字节数量 long skip（long n）:跳过几个字节不读 */public class FileInputerStreamDemo05 { public static void main(String[] args) { FileInputStream stream =null; try { //不适合太大的byte数组，因为byte数组不能太大 stream = new FileInputStream(&quot;src/tempfile2&quot;); System.out.println(&quot;总字节的数量：&quot;+stream.available()); byte[] bytes=new byte[stream.available()]; int read=stream.read(bytes); System.out.println(new String(bytes)); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (stream != null) { try { stream.close(); } catch (IOException e) { e.printStackTrace(); } } } }} 1.2FileOutputStream123456789101112131415161718192021222324252627282930313233343536373839404142434445package sen.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;/*文件字节输出流，负责写 从内存到硬盘 */public class FileOutputerStreamDemo01 { public static void main(String[] args) { FileOutputStream stream =null; try { //这种方式谨慎使用，会先将源文件清空，在写入 //以这种方式追加末尾 stream = new FileOutputStream(&quot;tempfile&quot;,true); byte[] bytes={97,98,99,100}; //将byte数组全部写出 stream.write(bytes); stream.write(bytes,0,2); //字符串 String s=&quot;我是一个中国人，我骄傲&quot;; //将字符串转换成数组 byte[] bs = s.getBytes(); stream.write(bs); //写完之后要刷新 stream.flush(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (stream != null) { try { stream.close(); } catch (IOException e) { e.printStackTrace(); } } } }} 1.2.1文件copy12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package sen.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;/*使用FileOutputStream + FileInputStream完成文件复制过程是一边读一边写使用字节流，文件类型随意，万能的 */public class copyDemo01 { public static void main(String[] args) { FileInputStream fis =null; FileOutputStream fos =null; try { //创建一个输入流对象 fis = new FileInputStream(&quot;F:\\\\Desktop\\\\学习笔记\\\\文件复制.mp3&quot;); //创建一个输出流对象 fos = new FileOutputStream(&quot;F:\\\\Desktop\\\\文件复制.mp3&quot;); //最核心的是：边读边写 byte[] bytes =new byte[1024*1024]; int readcount = 0; while ((readcount=fis.read(bytes))!=-1){ fos.write(bytes,0,readcount); } //输出流要刷新 fos.flush(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { } finally { //分开try，一起try，其中一个出现问题，会影响另一个流的关闭 if (fos != null) { try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } if (fis != null) { try { fis.close(); } catch (IOException e) { e.printStackTrace(); } } } }} 1.3FileReader123456789101112131415161718192021222324252627282930313233343536373839404142package sen.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;/*FileReader： 文件字符输入流，只能读取普通文本 读取文本内容时，笔记哦啊方便，快捷 */public class FileReaderDemo01 { public static void main(String[] args) { FileReader reader =null; try { reader = new FileReader(&quot;tempfile&quot;);// char[] chars=new char[4];// int readcount=0;// while ((readcount=reader.read(chars))!=-1){// System.out.print(new String(chars,0,readcount));// } char[] chars=new char[4]; reader.read(chars); for (char c :chars){ System.out.println(c); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (reader != null) { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } } }} 2缓冲流 Bufferedreader 12345678910111213141516171819202122232425262728package sen.File;import java.io.BufferedReader;import java.io.FileReader;/*Buffereader 带有缓冲区的字符输入流 使用这个留的时候不需要自定义char数组，或者不需要自定义byte数组，自带缓冲’ */public class BufferedDemo01 { public static void main(String[] args) throws Exception{ FileReader reader = new FileReader(&quot;tempfile&quot;); //当一个流的构造方法中需要一个流的时候，这个被传进来的流叫做：节点流 //外部负责包装的这个流，叫做：包装流，还有一个名字叫做：处理流 BufferedReader br = new BufferedReader(reader); //br.readLine()不带换行符 String s = null; while ((s= br.readLine())!=null){ System.out.println(s); } //关闭流 //对于包装流来说，只需要 关闭最外层流就行，里面的节点流会自动关闭 br.close(); }} 3转换流3.1InputStreamReader123456789101112131415161718192021222324252627282930package sen.File;import java.io.*;/*Buffereader */public class BufferedDemo02 { public static void main(String[] args) throws Exception { //字节流 FileInputStream in = new FileInputStream(&quot;tempfile&quot;); //通过转换流转换 //in是节点流，reader是包装流 InputStreamReader reader = new InputStreamReader(in); //这个构造方法只能传一个字符流，不能穿字节流 //reader是节点流 br是字符流 BufferedReader br = new BufferedReader(reader); String s = null; while ((s=br.readLine())!=null){ System.out.println(s); } //关闭流 br.close(); }} 4数据流4.1DateOutputStream1234567891011121314151617181920212223242526272829303132333435package sen.File;import java.io.DataOutputStream;import java.io.FileOutputStream;/*DateOutputStream:数据专属的 流这个流可以将数据连同数据的类型一并写入文件注意：这个文件不是普通文本（用记事本打不开） */public class DateOutputStreamDemo01 { public static void main(String[] args) throws Exception { DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;data&quot;)); byte b =100; short s = 200; int i = 300; long l= 400; float f = 3.0f; double d = 3.14; boolean sex = true; char c = 'a'; dos.writeByte(b); dos.writeShort(s); dos.writeInt(i); dos.writeLong(l); dos.writeFloat(f); dos.writeDouble(d); dos.writeBoolean(sex); dos.writeChar(c); dos.flush(); dos.close(); }} 4.2DataInputStream12345678910111213141516171819202122232425262728293031323334353637package sen.File;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;/*DataInputStream数据字节输入流DataOutputStream写的文件只能用DataInputStream去读，并且读的时候需要提前知道写入的顺序读的顺序和写的顺序一致 ，才可以正常取出数据 */public class DataInputStreamDemo { public static void main(String[] args) throws Exception{ DataInputStream data = new DataInputStream(new FileInputStream(&quot;data&quot;)); byte b=data.readByte(); short s = data.readShort(); int i = data.readInt(); long l = data.readLong(); float f = data.readFloat(); double d = data.readDouble(); boolean b1 = data.readBoolean(); char c = data.readChar(); System.out.println(b); System.out.println(s); System.out.println(i); System.out.println(l); System.out.println(f); System.out.println(d); System.out.println(b1); System.out.println(c); data.close(); }} 5File常用方法：1234567891011121314151617181920212223242526272829303132333435package sen.File;import java.io.File;/*File 1.File和四大家族没有关系，所以File类不能完成文件的读和写 2.File对象代表什么 文件和目录路径的抽象表示 */public class FileDemo { public static void main(String[] args) throws Exception { File file = new File(&quot;F:\\\\file&quot;); //以文件的形式创建// if (!file.exists()){// file.createNewFile();// } //以目录的形式创建// if (!file.exists()){// file.mkdirs();// } //可以创建多重目录吗 File file1 = new File(&quot;D:/a/b/c/d&quot;);// if (!file1.exists()){// file1.mkdirs();// } File file3 = new File(&quot;&quot;); String parent = file3.getParent(); System.out.println(parent); File parentFile = file3.getParentFile(); System.out.println(&quot;获取绝对路径&quot;+parentFile.getParentFile()); }} 12345678910111213141516171819202122232425262728293031323334package sen.File;import java.io.File;import java.text.SimpleDateFormat;import java.util.Date;/*File类常用方法 */public class FileDemo02 { public static void main(String[] args) { //获取文件名 File file = new File(&quot;F:\\\\Desktop\\\\学习笔记\\\\拷贝普通文本.txt&quot;); System.out.println(&quot;文件名：&quot;+file.getName()); //判断是否是一个目录 System.out.println(file.isDirectory());//false //判断是否是一个文件 System.out.println(file.isFile());//true //获取文件最后一次修改时间 long l = file.lastModified(); System.out.println(l);//是毫秒从1970年到现在 //将好眠转换成日期 Date time = new Date(l); SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;); String s = format.format(l); System.out.println(s); //获取文件大小 System.out.println(file.length()); }} 序列化 序列化：serialize Java对象从内存存储到硬盘文件中，将Java对象的状态保下来 反序列化：deserialize 将硬盘上的数据重新恢复到内存当中，恢复成java对象","link":"/2021/10/30/io%E6%B5%81/"},{"title":"java-面向对象","text":"java 基础知识 多态多态：多态是同一个行为具有多个不同表现形式或形态的能力。 多态存在的单个必要条件 继承 重写 父类引用指向子类对象：Persion p = new Child() 贴一段代码来看一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Test { public static void main(String[] args) { Animal a1 = new Cat(); Animal a2 = new Dog(); show(a1); show(a2); Animal a = new Cat(); a.eat(); Cat c = (Cat) a; c.work(); } public static void show(Animal a){ a.eat(); //类型判断 if(a instanceof Cat){//猫做得事情 Cat c = (Cat) a; c.work(); } if (a instanceof Dog){//狗做得事情 Dog c = (Dog) a; c.work(); } }}abstract class Animal{ abstract void eat();}class Cat extends Animal{ public void eat() { System.out.println(&quot;吃鱼&quot;); } public void work(){ System.out.println(&quot;抓老鼠&quot;); }}class Dog extends Animal{ public void eat(){ System.out.println(&quot;吃骨头&quot;); } public void work(){ System.out.println(&quot;看家&quot;); }} 运行结果 123456吃鱼抓老鼠吃骨头看家吃鱼抓老鼠 抽象类抽象类：在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 由于抽象类不能实力化，所以抽象类必须被继承，才能被使用。 举个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243public abstract class Employee{ private String name; private String address; private int number; public Employee(String name, String address, int number) { System.out.println(&quot;Constructing an Employee&quot;); this.name = name; this.address = address; this.number = number; } public double computePay() { System.out.println(&quot;Inside Employee computePay&quot;); return 0.0; } public void mailCheck() { System.out.println(&quot;Mailing a check to &quot; + this.name + &quot; &quot; + this.address); } public String toString() { return name + &quot; &quot; + address + &quot; &quot; + number; } public String getName() { return name; } public String getAddress() { return address; } public void setAddress(String newAddress) { address = newAddress; } public int getNumber() { return number; }} 该类和普通的类没有区别，依然有3个变量，一个构造方法，7个成员方法，现在如下编译时，会产生错误， 1234567891011public class AbstractDemo{ public static void main(String [] args) { /* 以下是不允许的，会引发错误 */ Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43); System.out.println(&quot;\\n Call mailCheck using Employee reference--&quot;); e.mailCheck(); }} 报错： 1234Employee.java:46: Employee is abstract; cannot be instantiated Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43); ^1 error 所以通过继承Employee类，来使用Employee的属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Salary extends Employee{ private double salary; //Annual salary public Salary(String name, String address, int number, double salary) { super(name, address, number); setSalary(salary); } public void mailCheck() { System.out.println(&quot;Within mailCheck of Salary class &quot;); System.out.println(&quot;Mailing check to &quot; + getName() + &quot; with salary &quot; + salary); } public double getSalary() { return salary; } public void setSalary(double newSalary) { if(newSalary &gt;= 0.0) { salary = newSalary; } } public double computePay() { System.out.println(&quot;Computing salary pay for &quot; + getName()); return salary/52; }}public class AbstractDemo{ public static void main(String [] args) { Salary s = new Salary(&quot;Mohd Mohtashim&quot;, &quot;Ambehta, UP&quot;, 3, 3600.00); Employee e = new Salary(&quot;John Adams&quot;, &quot;Boston, MA&quot;, 2, 2400.00); System.out.println(&quot;Call mailCheck using Salary reference --&quot;); s.mailCheck(); System.out.println(&quot;\\n Call mailCheck using Employee reference--&quot;); e.mailCheck(); }} 编译结果如下： 123456789Constructing an EmployeeConstructing an EmployeeCall mailCheck using Salary reference --Within mailCheck of Salary classMailing check to Mohd Mohtashim with salary 3600.0Call mailCheck using Employee reference--Within mailCheck of Salary classMailing check to John Adams with salary 2400. 详设计一个类，该类有一个特别的成员方法，具体实现意由它的子类确定，那么可以在父类中声明该方法是抽象方法，抽象方法只有一个方法名，没有方法体。 1234567public abstract class Employee { private String name; private String address; private int number; public abstract double computePay(); //其他方法} 声明抽象方法会造成两个结果： 一个类包含抽象方法，该类一定是抽象类 任何子类必须重写父类的抽象方法，或者声明自身是抽象类，最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。 123456789101112public class Salary extends Employee{ private double salary; // Annual salary public double computePay() { System.out.println(&quot;Computing salary pay for &quot; + getName()); return salary/52; } //其余代码} 抽象类总结： 抽象类不嫩被实例化，只有继承抽象类的非抽象子类才可以实例化对象 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类 抽象类中的方法只是声明，没有方法体， 构造方法，类方法（用static修饰的方法） 不嫩声明为抽象方法 抽象类的子类必须给出抽象方法的具体实现，除非它也被声明为抽象类 接口接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。 接口和类的区别： 接口不能用于实例化对象 接口没有构造方法 接口中所有的方法必须是抽象方法 接口中不能包含成员变量，除了static和finally声明的成员变量 接口和抽象类的区别： 抽象类中可以有方法体，，接口不行 抽象类中的方法可以是任何类型的，接口只能是static和finall 接口以下特性： 接口是隐式抽象的，当声明一个接口时，不必使用abstract 接口中的方法也是隐式抽象的，不必使用abstract 接口中的方法都是public的","link":"/2021/10/11/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"java-String类","text":"","link":"/2021/10/11/java-String%E7%B1%BB/"},{"title":"java-常用工具类","text":"java 常用工具类 一、util包下的常用类1.Collections常用方法： 12345678910111213public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c,T... elements)将所有指定元素添加到指定 collection 中。public static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list,T key)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定。public static &lt;T&gt; int binarySearch(List&lt;? extends T&gt; list,T key,Comparator&lt;? super T&gt; c)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且集合也事先必须是按照c比较器规则进行排序过的，否则结果不确定。public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，而且支持自然排序public static &lt;T&gt; T max(Collection&lt;? extends T&gt; coll,Comparator&lt;? super T&gt; comp)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，按照比较器comp找出最大者public static void reverse(List&lt;?&gt; list)反转指定列表List中元素的顺序。public static void shuffle(List&lt;?&gt; list) List 集合元素进行随机排序，类似洗牌public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)根据元素的自然顺序对指定 List 集合元素按升序排序public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; c)根据指定的 Comparator 产生的顺序对 List 集合元素进行排序public static void swap(List&lt;?&gt; list,int i,int j)将指定 list 集合中的 i 处元素和 j 处元素进行交换public static int frequency(Collection&lt;?&gt; c,Object o)返回指定集合中指定元素的出现次数public static &lt;T&gt; void copy(List&lt;? super T&gt; dest,List&lt;? extends T&gt; src)将src中的内容复制到dest中public static &lt;T&gt; boolean replaceAll(List&lt;T&gt; list，T oldVal，T newVal)：使用新值替换 List 对象的所有旧值public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)：返回指定列表支持的同步（线程安全的）列表public static &lt;T&gt; List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)返回指定列表的不可修改视图 1.1Comparator比较器排序，简单就是说比较两个对象之间的大小，在java中有两种比较方式，一个是实现java.lang.Comparable的接口，一种是实现java.util.Comparator的接口。 123456public int Comparator(String o1,String o2):比较两个参数的顺序两个对象比较的结果：&lt; &gt; =升序比较：o1 &gt; o2(正数) o1 &lt; o2 (负数)降序比较：o2 &gt; o1 (正数) o2 &lt; o1(负数) Demo: 123456789101112131415public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;abc&quot;); list.add(&quot;bac&quot;); list.add(&quot;cab&quot;); list.add(&quot;shb&quot;); Collections.sort(list,new Comparator&lt;String&gt;(){ //按照第一个单词降序 @Override public int compare(String o1, String o2) { return o2.charAt(0)-o1.charAt(0); } }); System.out.println(&quot;降序后的list:&quot;+list); } 1.2Comparable 和 Comparator的区别 Comparable: ​ 强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compaetTo 方法被称为她的自然比较方法。 只能在类中实现 compareTo() 一次，不能经常修改类的代码实现自己想要的排序，实现此接口的对象列表（和数组）可以通过 Collection.sort （和 Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无序指定比较器。 Comparator: ​ 强行对某个对象进行整体排序。可以将 Comparator 传递给 sort 方法（如Collection.sort 或 Array.sort），从而允许在排序上实现精确控制。 还可以使用 Comparator 来控制某些数据结构（如有序 set 或有序的映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。 Demo: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//Student类public class Student implements Comparable&lt;Student&gt; { private String name; private Integer age; public Student() { } public Student(String name, Integer age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; } @Override public int compareTo(Student o) { return this.age-o.age; }}//Testpublic static void main(String[] args) { List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student(&quot;sqs&quot;,24)); list.add(new Student(&quot;huang&quot;,22)); list.add(new Student(&quot;shihao&quot;,25)); list.add(new Student(&quot;zui&quot;,23)); /** * 让学生按照年龄升序 */ Collections.sort(list);//要求该list中元素类型，必须让该元素的类实现comparable接口 for (Student student : list) { System.out.println(student.toString()); } }-- 或者 public static void main(String[] args) { List&lt;Student1&gt; list = new ArrayList&lt;&gt;(); list.add(new Student1(&quot;sqs&quot;,22)); list.add(new Student1(&quot;huang&quot;,22)); list.add(new Student1(&quot;shihao&quot;,25)); list.add(new Student1(&quot;zui&quot;,23)); /** * 让学生按照年龄升序 */ Collections.sort(list, new Comparator&lt;Student1&gt;() { @Override public int compare(Student1 o1, Student1 o2) { //年龄排序 int result = o1.getAge()- o2.getAge(); if (result ==0 ){ //年龄一样，按照姓名首字符 result = o1.getName().charAt(0)-o2.getName().charAt(0); } return result; } }); for (Student1 student : list) { System.out.println(student.toString()); } } 总结：对于自定义的类型排序时，想要调用Collections.sort()或者Arrays.sort()时，必须指定一个比较器 在当前类中实现comparable接口，重写compareTo()方法，在里面指定比较方式 在调用sort（）方法时，在第二个参数的位置 new Comparator()对象，然后重写compare()方法 2.Calendar1234567891011121314151617181920212223242526272829public static void main(String[] args) { //获得一个Calendar的对象，是抽象类，无法new Calendar c = Calendar.getInstance(); //赋值时年月日时分秒常用的6个值。月份下标是从0开始 System.out.println(&quot;年&quot;+c.get(Calendar.YEAR)); System.out.println(&quot;月&quot;+c.get(Calendar.MONTH)+1); System.out.println(&quot;日&quot;+c.get(Calendar.DATE)); System.out.println(&quot;日&quot;+c.get(Calendar.DAY_OF_MONTH)); System.out.println(&quot;时&quot;+c.get(Calendar.HOUR_OF_DAY)); System.out.println(&quot;时&quot;+c.get(Calendar.HOUR)); System.out.println(&quot;分&quot;+c.get(Calendar.MINUTE)); System.out.println(&quot;秒&quot;+c.get(Calendar.SECOND)); //设置某个日期，可以一次设置年月日时分秒，也可以分开设置 c.set(2021,9,14,18,00); System.out.println(c.getTime()); //分开设置 c.set(Calendar.YEAR, 2018); c.set(Calendar.MONTH, Calendar.FEBRUARY); c.set(Calendar.DAY_OF_MONTH, 15); c.set(Calendar.HOUR_OF_DAY, 23); c.set(Calendar.MINUTE, 59); c.set(Calendar.SECOND, 59); System.out.println(c.getTime()); System.out.println(&quot;------&quot;); c.set(2018,0,31,0,0); c.add(Calendar.MONTH,1); System.out.println(c.getTime()); } 输出： 123456789101112131415年2021月91日14日14时14时2分16秒28Thu Oct 14 18:00:28 CST 2021Thu Feb 15 23:59:59 CST 2018------Wed Feb 28 00:00:59 CST 2018Process finished with exit code 0 3.日期操作类3.1Date1234567891011121314public static void main(String[] args) { Date date = new Date(); /** * Date 里面的无参构造调用了System.currentTimeMillis()回去了当前的时间 * public Date() { * this(System.currentTimeMillis()); * } * public Date(long date) { * fastTime = date; * } * */ System.out.println(date); } 从Date的构造方法中可以看出，Date类只是对long类型的一种包装，所以Date中一定存在日期与long类型转换的方法： 将long转换成Date:public Date(Loong date) 将Date换成long :public long getTime() 1234Date date = new Date();long current = date.getTime();current += 864000* 1000;//10天毫秒System.out.println(new Date(current)); long 之中存的毫秒，而不是秒，程序执行的都是以毫秒的量级 3.2SimpleDateFormat 将日期格式化：public final String format(Date date) 将字符串转为日期：public Date parse(String source) 构造方法：public SimpleDateFormat( String pattern) 1234567public static void main(String[] args) { Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;); String format = sdf.format(date); System.out.println(format); } 将字符串转换成Date 123456public static void main(String[] args) throws ParseException { String birthday = &quot;1998-12-12 16:11:11.111&quot;; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;); Date date = sdf.parse(birthday); System.out.println(date); } 4.UUID1UUID.randomUUID() 二、","link":"/2021/10/13/java-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"title":"markdown","text":"markdown 简单操作 Markdown标题三级标题字体helloworld！ helloworld！ helloworld！ helloworld！ 引用 选择狂神说java， 分割线 图片 超链接 点击跳转到学相伴 列表 沪电股份 今后 换个地方（-号加空格） 表格名字|性别|生日..|..|..|张三|男|1997 1.1 代码1public -","link":"/2021/10/30/markdown/"},{"title":"mybatis","text":"mybatis :图片目前不好使 Mybatismybatis提供了哪些功能： 提供了创建connection，statement，resultset的能力，不用开发人员来创建这些对象 提供了执行SQL语句的能力 提供了循环SQL，把SQL的结果转换成java对象，list集合的能力 提供了关闭资源的能力 开发员工做得事：提供sql语句 最后是：开发人员提供SQL语句—-mybatis处理SQL—-开发人员得到list集合或java对象（表中的数据） 总结：mybatis是一个SQL映射框架，提供的数据库的操作能力。增强的jdbc，使用mybatis让开发人员集中精神写sql就可以了，不必关心connection，statement，resultset，创建，关闭 步骤 ： mybatis.xml 主配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--环境配置;数据库的连接信息 default:必须和environments的id值一样 告诉mybatis使用那个数据库的连接信息，也就是访问那个 数据库 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!--environments：一个数据库信息的配置，环境 id:一个唯一值，自定义，表示环境的名称 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- transactionManager:mybatis 的事务类型 type:JDBC(表示使用jdbc中的connection对象的commit ，rollback，做事务处理) --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- dataSource:表示数据源，连接数据库的 type:表示数据源的类型，POOLED表示使用连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--sql mapper 映射的文件--&gt; &lt;mappers&gt; &lt;!--指定一个文件的位置 从类路径开始的路径信息 --&gt; &lt;mapper resource=&quot;com.sen.dao.StudentDao.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt;&lt;!--mybatis 的主配置文件，主要定义了数据库的配置信息，SQL映射文件的位置1.约束文件 &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;2.configuration：根标签--&gt; sql 映射文件 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.sen.dao.StudentDao&quot;&gt; &lt;select id=&quot;selectStudents&quot; resultType=&quot;com.sen.pojo.Student&quot;&gt; select * from syudent order by id asc &lt;/select&gt; &lt;!-- select： id:你要执行SQL的唯一标识，mybatis会使用这个id的值来找到要执行的SQL语句 可以自定义，但是要求你使用接口中的方法名 resultType:sql语句执行后 结果类型的 值写的是类型的全限定名称 --&gt;&lt;/mapper&gt;&lt;!--sql映射文件：写SQL语句的，mybatis会执行这些SQL1.指定约束文件&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; mybatis-3-mapper.dtd是约束文件的名称，扩展名是dtd的2.约束文件作用：限制，检查在当前文件中出现的标签，属性必须符合mybatis的要求3.mapper 是当前文件的根标签，必须的namespace：叫做命名空间，唯一值的，可以是自定义的名称q 要求是你使用dao接口的全限定名称。4.在当前文件中，可以使用特定的标签，表示数据库的特定操作 &lt;select&gt;:表示查询 &lt;update&gt;:表示更新数据库的操作 &lt;insert&gt;:inert语句 &lt;delete&gt;:删除语句--&gt; 测试 1234567891011121314151617181920212223242526272829303132333435363738package com.sen;import com.sen.pojo.Student;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;public class MyTest { public static void main(String[] args) throws IOException { //访问mybatis读取student数据 //1.定义mybatis主配置文件的名称，从根路径开始（target/classes） String config=&quot;mybatis.xml&quot;; //2.读取这个config文件 InputStream in = Resources.getResourceAsStream(config); //3.创建SQLsessionfactorybuilder SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //4.获取SqlSessionFactoryBuilder对象 SqlSessionFactory factory = builder.build(in); //5.【重要】获取SqlSession 对象，从SqlSessionFactory中获取获取SqlSession SqlSession sqlSession = factory.openSession(); //6.【重要】指定要执行的SQL语句标识.sql映射文件中的namespace+ &quot;.&quot; +标签的id值 String sqlId=&quot;com.sen.dao.StudentDao&quot; + &quot;.&quot; +&quot;selectStudents&quot;; //7.执行SQL语句 List&lt;Student&gt; list = sqlSession.selectList(sqlId); //8.输出 for (Student student:list){ System.out.println(student.toString()); } //9.关闭sqlSession sqlSession.close(); }} 开启日志： ​ 在mybatis.xml文件中添加 123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt; 2. 主要类的介绍 Resources:mybatis 中的类，负责读取主配置文件 1InputStream in = Resources.getResourceAsStream(config); ```SqlSessionFactoryBuilder:创建SqlSessionFactory对象//3.创建SQLsessionfactorybuilder SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); //4.获取SqlSessionFactoryBuilder对象 SqlSessionFactory factory = builder.build(in); 12345673. ```java SqlSessionFactory;重量级对象，创建一个对象耗时时间表较长，使用资源较多，在整个项目中有一个就够用了 SqlSessionFactory作用： SqlSession sqlSession = factory.openSession(); openSession()方法说明：五参数的：获取不是自提交的 openSession(boolean autoCommit)：获取自动提交的 ```javaSqlSession:SqlSession接口中定义了操作数据库的方法，例如selectone(),selectList(),insert(),update(),delete(),commit(),rollback()使用要求：SqlSession对象不是线程安全的，需要在方法内部使用，在使用Sql之前，使用openSession来获取SqlSession，在执行SQL语句后，需要关闭它，执行SqlSession.close，这样能保证他的使用是线程安全的 123456789101112131415161718192021222324# 3.封装成工具类```javapublic class MyBatisUtils { public static SqlSessionFactory sqlSessionFactory=null; static { String config=&quot;mybatis.xml&quot;; try { InputStream in = Resources.getResourceAsStream(config); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); sqlSessionFactory = builder.build(in); } catch (IOException e) { e.printStackTrace(); } } //获取sqlsession的方法 public static SqlSession getSqlSession(){ SqlSession sqlSession=null; if (sqlSessionFactory!=null) sqlSession= sqlSessionFactory.openSession(); return sqlSession; }} 4.mybatis的动态代理机制什么是动态代理：mybatis帮你中的==自动创建dao接口类的实现类，在实现类中调用sqlsession的方法执行sql语句 12345/**使用mybatis的动态代理机制，使用sqlsession.getMapper()getMapper能获取到接口对于实现类对象sqlsession.getMapper(StudentDao.class)*/ 5.传参parameterType: 掌握多个参数：使用@param 命令参数 使用@param（“参数名”） String name 参数是对象 SQL语句传的是对象中的属性值 按位置传参（用得少） map传参 #和$ 6.mybatis输出结果 resultType结果类型，指的是SQL语句执行后，数据转为java对象 mybatis执行SQL语句，mybatis调用类的无参构造，创建对象 mybatis把ResultSet指定列值付给同名的属性 返回是map，查的结果有3列，就报错 resultMap（属性名和列名不一样的第一种方式） :结果映射，指定列名和java对象的属性对应关系。 把email赋给了name ，所以name是email的值，而 email 没有赋值，则为空 resulttype和resultmap不能一起用 性名和列名不一样的第二种方式 7.模糊查询 第一种模糊查询 java代码中，来指定like的内容 第二种模糊查询 ：在mapper文件中拼接like的内容 总结： 8.动态SQL动态语句实现的是mybatis的标签， ,, 是判断条件的 语法： :用来包含多个的，当多个if有一个成立时，会自动增加一个where关键字，并去掉if中多余的and,or等 当都为空的时候， 就是查询所有 :循环java数组中的数组，list集合的，主要用在SQL的in语句中，eg：找id位 ，1001,1002,1003 的三个学生 select * from student where id in(1001,1002,1003 ) 用法1： ​ 语法规则： ==collection：表示接口中的方法参数的类型，如果是数组使用array，如果是list集合，使用list== 相当于list ==item：是自定义的表示数组或集合成员的变量==相当于i相当于 ==open：表示循环开始时的字符==相当于( ==close：循环结束时的字符==相当于) ==separator:集合成员之间的分隔符==相当于, 用法2：传的是对象 9.sql代码片段 10 指定多个mapper文件（第二种方式要回） 11页面pagehelper:数据分页","link":"/2021/10/30/mybatis/"},{"title":"paperHelper插件","text":"","link":"/2021/10/14/paperHelper%E6%8F%92%E4%BB%B6/"},{"title":"mysql","text":"mysql MySql 1.安装mysql 解压 把这个放到自己的目录下 添加环境变量 在E:\\Environment\\mysql-5.7.33新建配置文件ini 压缩包没有需要配置 12345[mysqld]basedir=E:\\environment\\mysql-5.7.33\\datadir=E:\\environment\\mysql-5.7.33\\data\\ 这个是自动生成的，不需要自己新建port=3306skip-grant-tables 启动管理员模式的cmd，并将路径切换到mysql下的bin目录，然后输入mysqld -install(安装mysql) cd /d E:\\environment\\mysql-5.7.33\\bin 在输入mysqld –initialize-insecure –user=mysql 初始化数据库文件 然后再次启动mysql然后用命令mysql -u root -p （P后面不要有空格，否则密码就变成了空格）进入nysql管理界面（密码可为空） 进入界面后在修改密码 1update mysql.user set authentication_string=password('123456') where user='root' and Host= 'localhost'; 最后输入flush privileges; 刷新权限 修改my.ini文件删除最后一句skip-grant-tables 重启mysql即可真常使用 net stop mysql net start mysql 链接上测试出现一下结果就OK了 用完exit退出就OK了 2.安装SQLyog链接: https://pan.baidu.com/s/1D_iRna8V90omfHsKHyeBtg 提取码: bqht 复制这段内容后打开百度网盘手机App，操作更方便哦 新建一个数据库school 新建一个表student 1字段：id,name,age 3.连接数据库命令行连接数据库 1mysql -uroot -p123456 --（注释）连接数据库 123456789101112131415161718update mysql.user set authentication_string=password('123456') where user='root' and Host= 'localhost';--修改用户密码flush privileges--刷新权限-----------------------------------------------所有的语句都使用;结尾show databases;--查看所有数据库use school--切换数据库show tables;--查看数据库中所有表describe student;--显示数据库中全部信息（若打错了，ctrl+c强行终止）create database westos;--创建一个数据库exit;--退出链接----单行注释（sql本身的注释）/*多行注释*/ DDL 定义 DML 操作 DQL 查询 DCL 控制 4.操作数据库操作数据库 &gt; 操作数据库表数据 4.1操作数据库 创建数据库 1CREATE DATABASE IF NOT EXISTS westos; 删除数据库 1DROP DATABASE IF EXISTS westos; 使==用==数据库 12-- tab键的上面。如果你的表名或者字段名是一个特殊字符，就需要带``USE `school`; 查看数据库 1show database;-- 查看数据库 4.2数据库的列类型 数值 tinyint 是十分小的数据 1个字节 smallint 较小的数据 2个字节 mediumint 中等大小的数据 3个字节 *int 标准的数据 4个数据**bigint 较大的数据 8个字节 float 单精度 4个字节 double 8个字节 decimal 字符串的浮点数（金融） 字符串 char 字符串固定的 0~255 varchar 可变字符串 0~65535，常用变量 tinytext 微型文本 2^8-1 text 文本串 2^16-1 ，保存大文本 时间日期 ​ java.util.Date date YYY-MM-DD ,日期格式 time HH:mm:ss 时间格式 datetime YYY-MM-DD HH:mm:ss 最常用的时间格式 **timestamp 时间戳 1970.1.1到现在的毫秒数 ** 也较为常用 year 年份表示 null 没有值 ==注意，不要使用null进行运算，结果为null== 4.3数据库的字段和属性（重点）==unsigned：== 无符号的整数 声明了该列不能为负数 ==zerofill:== 0填充的 不足的位数，使用0来填充 ==自增==： 通常理解为自增，自动在上一条记录的基础上+1（默认） 通常用来设计唯一的逐渐主键~index ，必须是整数、 可以自定义设计主键自增其实 ==非空== 假设设置为 notnull 如果不给他赋值，他就报错 ==默认== 设置默认值 sex ,默认值为男，如果不指定该列的值，则会有默认的值 ==每一个表必须存在的五个字段，未来做项目用的，表示一个记录存在的意义== 1234567/* 每个表必须要具备的东西id 主键`version` 乐观锁is_delete 伪删除gmt_create 创建时间gmt_update 修改时间*/ 4.4创建数据库表1.... 格式 123456createtable[if not exists] `表名`(`字段名` 列类型 [属性] [索引] [注释],`字段名` 列类型 [属性] [索引] [注释], ......`字段名` 列类型 [属性] [索引] [注释])[表的类型][字符集设置][注释] 常用命令 123show create database school--查看创建数据库的语句show create table student --查看student数据表的定义语句desc student --查看表的结构 4.5数据表的类型12345-- 关于数据引擎/*innodb 默认使用myisam 早些年使用*/ MYISAM INNODB 事务支持 不支持 支持 数据行锁定 不支持 支持 外键约束 不支持 支持 全文检索 支持 不支持 表空间的大小 较小 较大，约2倍 常规使用操作： MYISAM: 节约空间，速度较快 INNODB: 安全性高，事物的处理，多表多用户操作 在物理空间存在的位置 所有的数据库文件都存在data目录下 本质是文件的存储 设置数据库的字符编码 1charset=utf8 不设置的话 ，会是mysql默认的（不支持中文） 在my.ini中配置默认的编码 1character-set-server=utf8 4.6修改和删除 修改 12345678-- 修改表名ALTER TABLE student RENAME AS student1 ALTER TABLE student1 RENAME AS student-- 修改表的字段ALTER TABLE 表名 MODIFY 字段 VARCHAR(11)-- 修改约束ALTER TABLE 表名 CHANGE age age1 INT(1)-- 字段重命名-- 删除表的字段ALTER TABLE 表名 DROP 字段 删除 12-- 删除表(如果表存在再删除)DROP TABLE IF EXISTS teacher ==所有的创建和删除操作都加上条件判断，以免报错== 注意点： ``字段名 ‘ ‘ 单引号 注释 – /**/ sql关键字大小写不明感，简易大家小写 所有符号用英文 5.MySql的数据管理5.1外键（了解即可）删除有外键关系的表必须先删除主表，后删除从表 方式二：创建表成功后添加外键 1234ALTER TABLE `student` ADD CONSTRAINT `FK_gradeid` FOREIGN KEY(`gradeid`) REFERENCES `grade`(`gradeid`);-- ALTER TABLE 表 ADD CONSTRAINT 约束名 FOREIGN KEY(作为外键的列) REFERENCES 那个表（那个字段） 上面的是物理层面的外键 ==最佳实践== 在程序中实现 5.2DML语言（全部记住，背下来） insert update delete 5.3添加insert insert 1INSERT INTO `student`(`name`,`pwd`,`sex`)VALUES('张三','123','男'),('王五','456','男') 语法：insert into表名（字段）values（值） 5.4修改 update 修改谁（条件） set原来的置=新值 12345-- 修改UPDATE `student` SET `name`='秦疆' WHERE id=1;UPDATE `student` SET `birthday`=CURRENT_TIME WHERE id=1;-- 语法-- update 表名 set 字段 =value where 条件：where子句 运算符 id 等于某个值，大于某个值，在某个区间修改… 操作符 含义 范围 结果 = 等于 &gt;&lt;或！= 不等于 &gt; &lt; &gt;= &lt;= between…and… 闭合区间 and 2个条件&amp;&amp; or 或者|| 5.5 删除 删除 12-- 删除DELETE FROM `student` WHERE `id`=4; truncate命令 作用：完全清空一个数据库表，表的结构和索引约束不会变 1TRUNCATE `student` delete 和turncate区别 相同点：都能删除数据，都不会删除表结构 不同： truncate 重新设置自增列 计数器会归零 truncate不会影响事务 面试加分项：delete删除的问题，重启数据库，现象 innodb 自增列会冲1开始（存在内存中的，断点即失） myisam 继续会从上一个自增量开始（存在文件中的并不会丢失） ==6.DQL查询数据（重点）==6.1DQL 所有的查询操作都用它 select 简单的查询 复杂的查询它都能做 ==数据库最核心的语言== 使用频率最高的 6.2 指定查询字段 别名 123456-- 别名，给结果起一个名字 ASSELECT `studentno` AS 学号,`studentname` AS 姓名 FROM `student`-- 函数-- 函数concat(a,b)SELECT CONCAT ('姓名：',`studentname`) AS 新名字 FROM `student` 去重 distinct 作用：去除select查询出来的结果中重复的数据，只显示一条 12-- 发现重复数据 去重 SELECT DISTINCT `studentno` FROM `result` ​ 数据库的列（表达式） 12-- 学员成绩考试+1分 SELECT `studentresult`,`studentresult`+1 AS 提分后 FROM `result` ==数据库中的表达式:文本值，列，null ， 函数，计算表达式，系统表达式== select 表达式 from 表 6.3where条件子句作用：检索数据库中符合条件的值 逻辑运算符 运算符 语法 描述 and &amp;&amp; a and b a&amp;&amp;b l逻辑与 都真 or || a or b a||b 逻辑或 一真为真 not ! not a !a 逻辑非 ==尽量使用英文字母== 模糊查询：比较运算符 运算符 语法 描述 IS NULL a is null 如果操作符为null 则结果为真 IS NOT NULL a is not null 如果操作符为 not null 则结果为真 between a bewteen b and c 若a在b和c之间结果为真 like a like b sql 匹配 ，如果a匹配b ，则为真 in a in(a1,a2,a3) 假设a在a1 或者a2，其中的某一个值中，则为真 模糊查询 1234567891011121314-- 模糊查询-- 查询姓张的同学-- like %(代表0到任意一个字符) _（代表一个字符） SELECT `studentname` FROM `student`WHERE `studentname`LIKE '_伟';-- 查询名字中间有嘉的SELECT `studentname` FROM `student`WHERE `studentname`LIKE '%嘉%';-- in 查询1000 1001号的同学SELECT `studentname` FROM `student`WHERE `studentno` IN(1000,1001);-- ====null not nullSELECT`studentname` FROM `student`WHERE `address` =''; 6.4连表查询 join对比 123456/*1.分析需求，分析查询的字段来自那些表2.确定使用哪种链接查询 7中确定交叉点(两个表的哪个数据是相同的)判断条件：学生表的no=成绩表的no*/ 1234567891011121314151617-- join-- 查找参加考试的同学（学号姓名学科成绩）-- inner joinSELECT s.`studentno`,`studentname`,`subjectno`,`studentresult`FROM `student` sINNER JOIN `result` rWHERE s.`studentno`=r.`studentno`-- right joinSELECT s.`studentno`,`studentname`,`subjectno`,`studentresult`FROM `student` sRIGHT JOIN `result` rON s.`studentno`=r.`studentno`-- left joinSELECT s.`studentno`,`studentname`,`subjectno`,`studentresult`FROM `student` sLEFT JOIN `result` rON s.`studentno`=r.`studentno` 操作 描述 inner join 如果表中有一个匹配 就返回行（可用where 可用on） right join 会从右表中返回所有值，即使右表中没有匹配（必须on） left join 会从左表中返回所有值，即使右表中没有匹配（必须on） ==join on 连接查询== ==where等值查询==","link":"/2021/10/30/mysql/"},{"title":"nginx","text":"nginx nginx1.nginx基本概念：1.1nginx是什么，做什么事情1.2反向代理（掌握）1.2.1正向代理： 在浏览器配置代理服务器，通过代理服务器来进行互联网访问（访问谷歌浏览器） 1.2.2反向代理：反向代理是替服务器来接受客户端消息 区别(个人理解)： 正向代理:替客户端去连接另一台服务器 反向代理：替服务器去接受客户端的消息，代理服务器和目标服务器在客户端看来相当于是一个整体服务器。实际上，客户端只知道反向代理服务器的ip,并不知道目标服务器的ip。 1.3负载均衡（掌握）​ 1个客户端，发送15个请求个一个服务器，服务器撑不住，这时，需要一个反向代理服务器，将15个请求平均分发给3台服务器。 1.4动静分离（掌握）​ 为了加快服务器对网站的解析速度，将网站的静态资源和动态资源分不同的服务器来存储，环节单个服务器的压力。 ​ 2.nginx安装，常用命令和配置文件2.1在linux系统中安装nginx 首先下载Nginx 1wget http://nginx.org/download/nginx-1.17.0.tar.gz 然后解压下载的目录，进入解压目录中，在编译安装之前，需要安装两个依赖： 12yum -y install pcre-develyum -y install openssl openssl-devel 然后开始编译安装 123./configuremakemake install 装好之后，默认安装位置在： 1/usr/local/nginx/sbin/nginx 进入该目录的sbin目录下，执行./nginx即可启动Nginx 如果修改了Nginx的配置，通过如下重新加载Nginx配置文件 1./nginx -s reload 第二种： 安装pcre依赖 1tar -zxvf pcre-8.37.tar.gz 进入解压目录 1./configure 若报错：configure: error: You need a C++ compiler for C++ support.执行下面命令 1yum install -y gcc gcc-c++ 编译安装 1make &amp;&amp; make install 安装openssl和zlib 1yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 安装nginx,解压，进入解压目录，执行./configure make&amp;&amp;make install 安装成功之后 1/usr/local/nginx/sbin/nginx 启动nginx 1[root@localhost sbin]# ./nginx nginx配置文件： 12vim /usr/local/nginx/conf/nginx.confip:本机 port :80 2.2nginx常用命令123456781.查看nginx版本号 ./nginx -v2.启动nginx ./nginx3.g关闭nginx ./nginx -s stop 4.重新加载nginx ./nginx -s reload 2.3nginx配置文件3.nginx配置实例1-反向代理 实现效果 打开浏览器，在浏览器输入地址www.123.com,跳转到Linux系统Tomcat主页 准备工作 在Linux安装Tomcat，使用默认端口8080 解压Tomact 进入Tomcat的bin目录下，./startup.sh启动Tomcat服务器 对外开放访问的端口 12firewall-cmd --add-port=8080/tcp --permanentfirewall-cmd --reload 查看已经开发的端口号： 1firewall-cmd --list-all 在Windows中访问Tomcat服务器： ip:port 具体配置 在Windows系统中的host文件中进行域名和ip对应关系的配置 C:\\Windows\\System32\\drivers\\etc hosts文件中修改 192.168.247.128 www.123.com 测试：www.123.com 4.nginx配置实例2-负载均衡5.nginx配置实例3-动静分离6.nginx配置高可用集群7.nginx执行原理","link":"/2021/10/30/nginx/"},{"title":"redis命令","text":"redis的简单命令 1. Redis： 简介：Redis是一种数据库。能够存储数据。管理数据的一种软件。 Redis的数据大部分时间是存储在内存的，适合存储频繁访问，数据量比较小的数据。 2.Redis的特点 支持数据持久化 支持多种数据结构 不仅支持kay-value类型的数据，同时 还提供list，set，zset，hash 支持数据备份 支持master-slave模式的数据备份 3.Windows安装Redis 下载安装包 https://github.com/dmajkic/redis/releases 解压到环境文件夹中 开启Redis 使用Redis客户端来连接Redis 记住一句话，Windows下使用确实简单，但是Redis推荐使用Linux去开发 4.Linux安装 将安装包传到Linux上 解压Redis到/opt目录 tar -zxvf redis-5.0.12.tar.gz -C /opt 编译Redis，进入解压目录，并且执行make命令： 会报错 ，没有cc命令 则需要安装gcc 就需要使用yum进行安装，执行命令；yum -y install gcc 执行 gcc - v查看Linux的内核版本 再次回到Redis目录执行make命令 还会报错，因为第一次编译的文件有些会存在，第二次编译就会报错，所以要进行清理工作 make distclean 然后执行make install 来安装Redis 后台启动Redis：usr/local/bin redis-server 启动Redis服务： 前台启动：在任何目录下执行 redis-server 后台启动：在任何目录下执行 redis-server &amp;(没改配置文件) 启动Redis服务时：指定配置文件： redis-server redis.conf &amp;(改配置文件) 关闭Redis服务： 通过kill来关闭（暴力不推荐,容易丢失数据） ps -ef|grep redis查看pid kill -9 pid 通过Redis命令关闭 redis-cli shutdown redis的客户端：通过网络连接到redis服务器，从而实现redis服务器的交互，向服务端发送命令，并且显示redis服务处理结果。 redis-cli:是redis自带客户端，使用命令redis-cli就可以启动redis的客户端程序。 redis-cli:默认连接本机（127.0.0.1）上的6379端口上的redis服务 redis-cli -p 端口号：连接127.0.0.1（本机）指定端口上的服务 redis-cli -h ip地址 -p 端口号：连接指定主机上的指定端口的redis服务 退出客户端：在客户端执行命令：exit或者quit 5.redis的基本知识： 测试redis服务的性能：src里在任何目录下redis-benchmark （了解） 查看redis服务是否正常运行： ping 如果正常——pong 查看redi服务器s的统计信息：info info 查看redis所有的统计信息 info [信息段]：查看redis服务器 指定的统计信息，如：info replication：查看集群 redis默认使用16个库（==理解==） redis中的数据库实例只能有redis服务来创建和维护，开发人员不能修改和自行创建数据库实例；默认情况下，redis会自动创建16个数据库实例，并且给16个数据库进行编号，从0开始到15，使用时，通过编号来使用数据库；可以通过配置文件来制定redis自动创建数据库的个数；每一个数据库实例，本身占用的存储空间是很少的，所以也不会造成存储及空间的太多浪费 默认情况下，redis客户端连接的是编号位0的数据库实例； 使用select index 来切换数据库 查看数据库中key的数目：dbsize 查看当前数据库到底有哪些k:**keys *** 清空数据库实例：flushdb 清空所有数据库实例：flushall 查看redis中所有的配置信息：**config get *** 查看redis中指定的配置信息：config get parameter 清屏；clear 6.redis的5种数据结构redis是用来存储数据的，程序处理完的数据要存储到redis数据库中，不同特点的数据要存储在redis中不同类型的数据结构中。 字符串： list列表（有序，可重复） set集合（无序，不可重复） zset:必须后面跟着一个数，来排序，没有数就不要用这个结构 hash 7.redis常用的操作命令：string：单key:单value list：单key：多有序value：contacts：a,c,v, set:单key:多无序value：city:bj,sh,tj hash 单key：对象（属性：值）： student：id:1001,name:张三,age:20(k:v) zset 单key：多有序value： city:2000 bj,1500 sh ,1000 tj, 1200 cq(有个参照标准，升序排) 有序指的是排序 Redis中关于key的操作 123456789101112131415keys: 1.keys *,所有匹配0个或者多个字符 2.keys k*:以k开头 3.keys [jdsfsjf]hello:在[]里面匹配一个字符 4.keys k?d:匹配一个字符del :删除 del key || del k1 k2:返回删除的个数rename key :对key重命名dbsize:数据库中元素个数ttl key:查看某个key的生命周期expire key seconds: 设置key的生命周期select index :切换数据库type key :查看key的类型config get *: 查看配置exists key :key 是否存在，返回1/0 String 12345678910111213141516171819202122232425append key value :最佳字符串 ，返回的是追加后的长度strlen key :长度incr key :+1 ,若key不存在，设置一个key值，初始化为0decr key incrby key offset getrange key startIndex endIndex:获取字符串key中start，end的子字符 闭区间 可以为负的，从右到左setrange key offset value :放值setex key seconds value :设置值得同时最大生存周期（秒）setnx key value :解决了set key value ,覆盖了之前的数据，若存在，不设值，不存在，随便mset k v k v k v k v k v:批量设值mget k1 k2 k3:批量获取msetnx k v k v k v k v：当所有key都不存在时，才会设置成功，只要有一个就设置失败ttl：查看有效期psetex:毫秒在redis中字符串都是以二进制的方式来存储的BIT:SET K1 a a 对应的ASCII97 转为2进制为01100001 bit的相关命令就是对二进制进行操作的getbit k对应的value在offset处的value值 例如 set k1 agetbit k1 0 ----&gt;0getbit k1 1 ----&gt;1getbit k1 2 ----&gt;1getbit k1 3 ----&gt;0setbit :修改key 对应的value在offset处的值bitcount: 统计二进制中1的个数 list 12345678lpush key value value:将一个或者多个值插入列表的表头（往左侧放）lrange key start end :获取指定列表中的指定下标区间的元素 rpush list01 2 3 :将一个或者多个值插入列表的表头（往右侧放）lpop key :从指定列表中移除（表头）元素并返回表头元素lindex:返回列表中，下标为index的元素ltrim:集合截取blpop:阻塞式的弹出，相当于lpop的阻塞版 set 1234567891011121314sadd: 添加元素到一个key中smembers:获取一个key下的所有元素srem;移除指定的元素sismember:返回一个元素是否在集合中scard:返回集合的数量srandmember：随机返回集合里的元素spop:随机返回并且出栈一个元素smove：把一个元素从一个集合一道另一个集合中sdiff:返回两个集合的差集(以第一个为准，看第一个元素少啥)sinter:两个集合的交际 sdiffstore: 这个类似于sdiff，不同的是，计算出来的结果会保存在一个新的集合中SDIFFSTORE k3 k1 k2sinterstore :将计算出来的结果保存在一个新的集合中sunion:求并集 hash() student：id:1001,name:张三,age:20** 在hash中key是一个字符串，value是一个k:v键值对 123456789101112131415hset：添加值hget： 获取值hmset :批量设置值hmget :批量获取值hdel:删除指定的filed(value中的value值)hsetnx :默认情况下，可以和filed相同，会覆盖掉已有的value，hsetnx不会hvals:获取所有的valuehkeys :获取所有的keyhgetall :同时获取key和valuehexists:返回filed是否存在hincrby:给指定的value 自增1hincrbyfloat:hdecrby:hlen:返回某个key中的value的数量 hstrlen：返回某个key中的某一个filed的字符串长度 zset 1234567891011121314151617zadd:将指定的元素添加到有有序集合中zscore:返回member的scope值zrange:返回集合中的一组元素zrange k1 0 3 withscores: 返回一组元素(带值)zrevrange:返回一组元素，倒序 zcard:元素个数zcount:返回score在某个区间内的元素的个数zcount k1 60 90 闭区间zcount k1 (60 (90 开区间zrangebyscore:按照score的范围返回元素zrank:返回members的排名zrank k1 v1(从小到大)zrevrank k1 v1：(从大到小)zincrby:score 自增zinterscore:取交集，放到信集合里zrem:弹出一个元素zlexcount:计算members的数量 zrangebylex:返回指定区间内的成员 key 1234567del:删除一个k:vdump:序列化给定的key exists k: 判断k是否存在ttl:查看k的有效期 -1 永不过期， -2 已经过期， 其他是是有效期 expire ：给k设置有效期,如果在k过期之前被重新set了，则过期时间失效 persist:移除k的过期时间pttl:返回的是ms 补充 12五种数据类型，在第一次使用的时候，如果容器不存在，会自动创建一个 如果里面没有元素了，那么立即删除容器，释放内存 8.Redis 的 java客户端1.开启远程连接123456Redis默认是不支持远程连接的，需要手动开启修改两个地方1.绑定主机注释掉好像得需要把保护模式变成no2.开启密码校验改完之后 启动redis 2.Jedis2.1连接测试 创建一个普通的maven项目 添加jedis依赖 1234567&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt; 创建一个测试方法 1234567//1.构造jedis对象 Jedis jedis = new Jedis(&quot;192.168.5.131&quot;,6379); //2. 密码认证 jedis.auth(&quot;sqs102428&quot;); //测试是否连接成功 String ping = jedis.ping(); System.out.println(ping); 对于jedis而言，连接上redis就很简单， 在jedis中，方法的API和redis的命令高度一致由于 2.2连接池在实际应用中，jedis实例一般是从连接池中获取的，由于jedis是线程不安全的，所以在使用的时候，从连接池中取，用完还给连接池 1234567891011121314public class JedisPoolTest { public static void main(String[] args) { //1.构造连接池 JedisPool pool = new JedisPool(&quot;192.168.5.131&quot;,6379); //2.从连接池中获取jedis连接 Jedis jedis = pool.getResource(); jedis.auth(&quot;sqs102428&quot;); //3.jedis操作 String ping = jedis.ping(); System.out.println(ping); //4.归还连接 jedis.close(); }} 第三步抛出异常的话，会导致第四步无法归还，所以对代码改进， 12345678910111213141516171819public class JedisPoolTest { public static void main(String[] args) { //1.构造连接池 JedisPool pool = new JedisPool(&quot;192.168.5.131&quot;,6379); //2.从连接池中获取jedis连接 Jedis jedis = pool.getResource(); jedis.auth(&quot;sqs102428&quot;); //3.jedis操作 try{ String ping = jedis.ping(); System.out.println(ping); }catch (Exception e){ e.printStackTrace(); }finally { //4.归还连接 if (jedis != null) { jedis.close(); } } 利用jdk1.7的特性，try-with-resource,对代码改造 123456JedisPool pool = new JedisPool(&quot;192.168.5.131&quot;, 6379); try(Jedis jedis = pool.getResource()){ String ping = jedis.ping(); System.out.println(ping); } 进一步改进 12345678910111213141516171819202122232425262728293031323334public interface CallWithReedis { void call(Jedis jedis);}public class Redis { private JedisPool pool; public Redis() { GenericObjectPoolConfig config = new GenericObjectPoolConfig(); //连接池最大空闲数 config.setMaxIdle(300); //最大连接数 config.setMaxTotal(1000); //连接最大等待时间 config.setMaxWaitMillis(3000); //在空闲时检查有效性 config.setTestOnBorrow(true); pool = new JedisPool(config,&quot;192.168.5.131&quot;,6379,3000,&quot;sqs102428&quot;); } public void excute(CallWithRedis callWithRedis){ try(Jedis jedis = pool.getResource()){ callWithRedis.call(jedis); } }}public class JedisPoolTest { public static void main(String[] args) { Redis redis = new Redis(); redis.excute(jedis -&gt; { jedis.auth(&quot;sqs102428&quot;); System.out.println(jedis.ping()); }); }} 3.Lettuce","link":"/2021/10/30/redis%E5%91%BD%E4%BB%A4/"},{"title":"springboot缓存","text":"springboot简单实现缓存 一、springboot + redis 加入两个依赖 cache redis application.properties 连接redis： 123spring.redis.host=redis的服务器IPspring.redis.password=密码spring.redis.port=6379 在启动类上加@EnableCache：开启缓存功能 4个注解 @Cacheable 1.@Cacheable(cacheNames = “c1”) :注解标注在方法上，表示该方法的返回值需要放到缓中 2.默认情况下，缓存的key是方法的参数 @EnableCaching:开启缓存功能 @CachePut:更新缓存 @CachePut(cacheNames= “c1”,key=“#user.id”) public User updateUser(User user){ ​ return user; } @CacheEvict:删除缓存 Demo1 1234567891011121314151617181920212223242526272829//User类//加入缓存，实现serializable 接口public class User implements Serializable { private String username; private Long id; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } @Override public String toString() { return &quot;User{&quot; + &quot;username='&quot; + username + '\\'' + &quot;, id=&quot; + id + '}'; } Service 类： 1234567891011public class UserService { @Cacheable(cacheNames = &quot;c1&quot;)//标记在方法上，表示该方法的返回值存到缓存中 //默认情况下，方法的参数作为缓存的key public User getUserByUserId(Long id){ System.out.println(&quot;getUserByUserId:&quot;+id); User user = new User(); user.setId(id); user.setName(&quot;sqs&quot;); return user; }} 测试结果： 123456789101112@Testvoid contextLoads(){ for(int i=0;i&lt;3;i++){ User u = userService.getUserById(98L); System.out.println(&quot;u=&quot;+u); }}输出结果：getUserById:98u=User{username='sqs',id=98}u=User{username='sqs',id=98}u=User{username='sqs',id=98} redis里面的存储情况： Demo2 12345678910111213141516171819202122232425//多个参数时，key的值是什么 /** * 默认情况下，方法的参数将作为缓存的key * 方法存在对个参数，则默认情况下，多个参数共同作为缓存的key * 1.通过key=“#参数名” 来指定缓存key * 2.也可以使用SPEL的表达式 * * @param id * @param username * @return */public User getUserById2(Long id,String name){ User user = new User(); user.setId(id); user.setName(name); return user;} @Testvoid contextLoads(){ User u1 = userService.getUserById2(99L,&quot;zhangsan&quot;); User u2 = userService.getUserById2(99L,&quot;zhangsan&quot;);}输出：getUserById2:99 //执行一次 默认情况下，方法的参数将作为缓存的key 方法存在对个参数，则默认情况下，多个参数共同作为缓存的key1.通过key=“#参数名” 来指定缓存key2.也可以使用SPEL的表达式 第一种方式指定key： 123456789101112指定key：# + 参数名， 只要id一样，那就可以从缓存中取@Cacheable(cacheNames = &quot;c2&quot;,key = &quot;#id&quot;) public User getUserById2(Long id,String name){}@Testvoid contextLoads(){ User u1 = userService.getUserById2(99L,&quot;zhangsan&quot;); User u2 = userService.getUserById2(99L,&quot;lisi&quot;);}输出结果： 代码没有错，getUserById2:99User{username='zhangsan', id=99} 逻辑有错误 第二种方式指定key：使用spel表达式 12345678@Cacheable(cacheNames = &quot;c2&quot;,key = &quot;#root.method.name&quot;) public User getUserById2(Long id,String name){}@Testvoid contextLoads(){ User u1 = userService.getUserById2(99L,&quot;zhangsan&quot;); User u2 = userService.getUserById2(99L,&quot;lisi&quot;);} 第三种指定key的方式：完全指定key 1234567891011//创建一个MyKeyGenerator类@Componentpublic class MyKeyGenerator implements KeyGenerator { @Override public Object generate(Object target, Method method, Object... params) { String s = target.toString() + &quot;:&quot; + method.getName() + &quot;:&quot; + Arrays.toString(params); return s; }} @Cacheable(cacheNames = &quot;c2&quot;,keyGenerator = &quot;myKeyGenerator&quot;)public User getUserById2(Long id,String name){} Demo3:缓存的更新 12345678910111213141516@CachePut(cacheNames = &quot;c1&quot;,key = &quot;#user.id&quot;)public User updateUser(User user){ return user}@Testvoid contextLoads(){ User u1 = userService.getUserById(100L); u1.setName(&quot;wangwu&quot;); userService.updateUser(u1); User u2 = userService. getUserById(100L); System.out.println(u2)}输出：getUserById:100User{username='wangwu', id=100} Demo4:删除缓存：默认先删除数据库，在删除缓存 ,beforeInvocation =true,是先删除缓存，后删库 12345678910111213141516@CacheEvict(cacheNames = &quot;c1&quot;,key=&quot;#id&quot;)public void deleteUserById(Long id){ sout(&quot;deleteUserById：&quot; + id);}@Testvoid contextLoads5(){ //上一步缓存中有user={id:100,username:wangwu} userService.deleteUserByTd(100L); User u = userService.getUserById(100L); System.out.println(u); }输出：deleteUserByTdgetUserById:100User{username='sqs', id=100} 二、springboot+ehcache","link":"/2021/10/15/springboot%E7%BC%93%E5%AD%98/"},{"title":"spring5","text":"spring5框架基础知识 1.Spring框架介绍2.IOC容器2.1IOC底层原理2.2IOC接口（BeanFactory）2.3IOC操作Bean管理（基于xml）2.4IOC操作Bean管理（基于注解）3.AOP4.JdbcTemplate 什么是JdbcTemplate spring框架对JDBC进行封装，使用JdbcTemplate方便实现对数据库操作 准备工作 引入相关依赖或者jar包 在spring的配置文件中配置数据库连接池 12345678&lt;!--数据库连接池配置--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;clone&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///user_db&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;/bean&gt; 配置JdbcTemplate 对象，注入DataSource 123456&lt;!--JdbcTemplate对象--&gt; &lt;!--这个配置不像是springboot，只要你写上他就给你自动配置，而是需要你自己配置--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!--注入DataSource--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 创建service类，创建dao类，在dao注入jdbcTemplate对象 12&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt; 可以使用配置类来扫描 JdbcTemplate操作数据库 创建实体类 在dao中实现数据库添加操作 调用update方法，里面有两个参数 sql语句 参数 5.事务管理6.Spring5新特性","link":"/2021/10/27/spring5/"},{"title":"springcloud","text":"springcloud笔记 支付模块下 测试： 浏览器 - - http://localhost:8001/payment/create?serial=atguigu002 报错：？ 因为浏览器不大支持post请求，使用postman来请求 热部署 加依赖 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 向父工程里加入插件 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 开启自动编译 settings——complier ——abdc 全部打钩 Ctrl+Alt+shift+/ 打两个钩 compiler.automake.allow.when.app.running actionSystem.assertFocusAccessFromEdt 重启idea 消费者订单模块（上） 新建一个order80的module 服务之间调用 传统是使用httpClient , 在这里我们使用RestTemplate RestTemplate介绍：提供了多种便捷方式访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是spring提供的用于访问Rest服务的客户端模板工具集 官网地址 使用方法： 使用restTemplate访问restful接口非常的简单粗暴无脑（url,requestMap,ResponseBean.class）这三个参数分别代表REST请求地址，请求参数，HTTP响应转换被换成的对象类型。 在配置类中返回RestTemplate的对象。 123456789101112public static final String PAYMENT_URL = &quot;http://cloud-payment-service&quot;; @Autowired private RestTemplate restTemplate; @GetMapping(&quot;/consumer/payment/create&quot;) public CommonResult&lt;Payment&gt; create(Payment payment){ return restTemplate.postForObject(PAYMENT_URL+&quot;/payment/create&quot;,payment,CommonResult.class); } @GetMapping(&quot;/consumer/payment/get/{id}&quot;) public CommonResult getPayment(@PathVariable(&quot;id&quot;) Long id){ return restTemplate.getForObject(PAYMENT_URL+&quot;/payment/get/&quot;+id,CommonResult.class); } 消费者订单模块（下） 工程重构 新建一个module，将公共部分放进去，然后maven clean 和 install命令 将module打包进入仓库，其他服务调用。 Eureka基础知识 什么是服务治理 Spring Cloud封装了Netflix 公司开发的Eureka模块来实现服务治理 在传统的RPC远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。 Eureka的两个组件： Eureka Server提供服务注册服务 各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。 Eureka Client通过注册中心进行访问 它是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒) EurekaServer服务端安装 IDEA生成eurekaServer端服务注册中心，类似物业公司 创建cloud-eureka-server7001的module 添加pom依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka- server&lt;/artifactId&gt;&lt;/dependency&gt; 写yml,这个地方不用写spring.application.name=，物业中心不需要写自己的名字 12345678910 单机版eureka: instance: hostname: localhost #eureka服务端的实例名字 client: register-with-eureka: false #表识不向注册中心注册自己 fetch-registry: false #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务 service-url: #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址 defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ ```java@EnableEurekaServer意思是标注哪个是物业公司，哪个是入住企业 1234567 + 测试————-&gt; localhost:7001 服务注册中心eureka启动成功17. 支付微服务8001入驻eurekaServer + ```java @EnableEurekaClient 加pom 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; yum 1234567eureka: client: # 表示将自己注册到EurekaServer 默认为TRUE register-with-eureka: true fetchRegistry: true service-url: defaultZone: http://localhost:7001/eureka 单机版 测试 ​ 刷新eureka的注册中心，8001服务注册进去 eureka注册中心的application的名字和 123spring: application: name: cloud-payment-service 要保持一致 订单微服务80入驻eurekaServer pom yum 1234567891011spring: application: name: cloud-order-serviceeureka: client: # 表示将自己注册到EurekaServer 默认为TRUE register-with-eureka: true fetchRegistry: true service-url: defaultZone: http://localhost:7001/eureka ```java@EnableEurekaClient 123456789101112131415161718 + 测试 &gt; 两个微服务注册进去了 &gt; &gt; 访问http://localhost/consumer/payment/get/31也是好使的19. Eureka集群原理说明 互相注册，相互守望20. Eureka集群环境搭建 + 该映射文件C:\\Windows\\System32\\drivers\\etc\\hosts ```txt 127.0.0.1 eureka7001.com 127.0.0.1 eureka7002.com 将7001的hostname改成以下的样子 123eureka: instance: hostname: eureka7001.com #eureka服务端的实例名字 集群设置 12defaultZone: http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/体现了相互注册，相互守望的原理 ​ 测试 ———-&gt;eureka7001.com:7001 d订单支付两个微服务注册金eureka 先启动eureka7001,7002 在启动8001,8002 在启动80 当注册了两个provider的时候，消费者调用提供者是调用哪一个呢？ 这时需要将order访问提供者的IP地址改成服务的名称 1public static final String PAYMENT_URL = &quot;http://cloud-payment-service&quot;; 这时报错，找不到cloud-payment-service，无法识别 @LoadBalanced//提供负载均衡的功能 123456789@Configurationpublic class ApplicationContextConfig { @Bean @LoadBalanced//提供负载均衡的功能 public RestTemplate getRestTemplate(){ return new RestTemplate(); }} 支付微服务集群配置 _actuator微服务信息完整 authator是eureka的图形化界面 主机名称：服务名称修改 ```javainstance: instance-id: payment8001123456789 输入localhost:8001/actuator/health 显示{“status”:”up”}+ 访问信息有ip信息提示 + ```java prefer-ip-address: true #访问路径就可以显示ip 服务发现Discovery,这个可以得到任何的服务信息 加入注解 1@EnableDiscoveryClient ```java@GetMapping(“/payment/discovery”) public Object discovery(){ List&lt;String&gt; services = discoveryClient.getServices(); for (String element : services) { log.info(&quot;******element: &quot;+element); } List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;); for (ServiceInstance instance : instances) { log.info(instance.getServiceId()+&quot;\\t&quot;+instance.getHost()+&quot;\\t&quot;+instance.getPort()+&quot;\\t&quot;+instance.getUri()); } return this.discoveryClient; } 1234567891011121314151625. Eureka的自我保护理论知识 某时刻某一个微服务不可用了，Eureka不会立即清理，依旧会对该微服务的信息进行保存26. 禁用自我保护进制 7001 ```java eureka: ... server: #关闭自我保护机制，保证不可用服务被及时踢除 enable-self-preservation: false eviction-interval-timer-in-ms: 2000 8001 1234567891011eureka: ... instance: instance-id: payment8001 prefer-ip-address: true #心跳检测与续约时间 #开发时没置小些，保证服务关闭后注册中心能即使剔除服务 #Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒) lease-renewal-interval-in-seconds: 1 #Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务 lease-expiration-duration-in-seconds: 2 -Eureka停更说明 支付服务注册进zookeeper 服务提供者 pom 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;dependencies&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.sqs&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合zookeeper客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt; &lt;!--先排除自带的zookeeper3.5.3 防止与3.4.9起冲突--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--添加zookeeper3.4.9版本--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; yml 12345678server: port: 8004spring: application: name: cloud-provider-payment8004 cloud: zookeeper: connect-string: 192.168.5.131:2181 主启动类 1234567@SpringBootApplication@EnableDiscoveryClientpublic class PaymentMain8004 { public static void main(String[] args) { SpringApplication.run(PaymentMain8004.class,args); }} Controller 123456@Value(&quot;${server.port}&quot;) private String serverPort; @RequestMapping(&quot;/payment/zk&quot;) public String paymentzk(){ return &quot;springcloud with zookeeper :&quot;+serverPort+&quot;\\t&quot;+ UUID.randomUUID().toString(); } 启动8004注册进zookeeper（要先启动zookeeper的server） 临时还是持久节点 是临时节点 订单服务注册进zookeeper 服务消费者 module cloud-consumerzk-order80 pom 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;org.sqs&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-consumerzk-order80&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.sqs&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合zookeeper客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt; &lt;!--这个地方视频是需要把它给排除，我的zookeeper是3.7的，没有排除--&gt; &lt;!-- &amp;lt;!&amp;ndash;先排除自带的zookeeper3.5.3 防止与3.4.9起冲突&amp;ndash;&amp;gt;--&gt; &lt;!-- &lt;exclusions&gt;--&gt; &lt;!-- &lt;exclusion&gt;--&gt; &lt;!-- &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;--&gt; &lt;!-- &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;--&gt; &lt;!-- &lt;/exclusion&gt;--&gt; &lt;!-- &lt;/exclusions&gt;--&gt; &lt;/dependency&gt; &lt;!--添加zookeeper3.4.9版本--&gt; &lt;!-- &lt;dependency&gt;--&gt; &lt;!-- &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;--&gt; &lt;!-- &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;--&gt; &lt;!-- &lt;version&gt;3.4.9&lt;/version&gt;--&gt; &lt;!-- &lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; yml 123456789server: port: 80spring: application: name: cloud-consumerzk-order80 cloud: zookeeper: connect-string: 192.168.5.131:2181 主启动 业务类 配置Bean 12345@Bean @LoadBalanced public RestTemplate getRestTemplate(){ return new RestTemplate(); } Controller 1234567891011121314@RestController@Slf4jpublic class OrderZKController { public static final String INVOKE_URL=&quot;http://cloud-provider-payment8004&quot;; @Autowired private RestTemplate restTemplate; //getForObject和getForEntity有什么区别 @RequestMapping(&quot;/consumer/payment/zk&quot;) public String paymentInfo(){ //这个就是order调用zookeeper里的cloud-provider-payment8004 String result = restTemplate.getForObject(INVOKE_URL + &quot;/payment/zk&quot;, String.class); return result; }} Consul 简介看博客：https://blog.csdn.net/u011863024/article/details/114298270 安装并运行Consul 查看版本 consul -v cmd启动 consul agent -dev 浏览器输入localhost:8500出现图形界面 服务提供者注册进consul 新建cloud-providerconsul-payment8006 pom 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;org.sqs&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;cloud-providerconsul-payment8006&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt; &lt;dependency&gt; &lt;groupId&gt;org.sqs&lt;/groupId&gt; &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!--SpringCloud consul-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--日常通用jar包配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; yml 123456789101112server: port: 8006spring: application: name: cloud-providerconsul-payment8006 cloud: consul: host: localhost port: 8500 discovery: service-name: ${spring.application.name} 主启动 业务类 12345678910@RestController@Slf4jpublic class PaymentController { @Value(&quot;${server.port}&quot;) public String serverPort; @RequestMapping(&quot;/payment/consul&quot;) public String paymentConsul(){ return &quot;springcloud with consul :&quot;+serverPort+&quot;\\t&quot;+ UUID.randomUUID().toString(); }} 测试 http://localhost:8006/payment/consul 服务消费者注册进Consul pom 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;cloud2020&lt;/artifactId&gt; &lt;groupId&gt;org.sqs&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;order80 - cloud-consumerconsul-order80&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--SpringCloud consul-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- SpringBoot整合Web组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--日常通用jar包配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; yml 123456789101112server: port: 80spring: application: name: order80 - cloud-consumerconsul-order80 cloud: consul: discovery: service-name: ${spring.application.name} host: localhost port: 8500 业务类 测试 三个注册中心的异同点","link":"/2021/11/18/springcloud/"},{"title":"sql语句练习","text":"SQL语句练习，习题来源于网络，SQL语句有部分参考。 表名和字段–1.学生表Student(s_id,s_name,s_birth,s_sex) –学生编号,学生姓名, 出生年月,学生性别–2.课程表Course(c_id,c_name,t_id) – –课程编号, 课程名称, 教师编号–3.教师表Teacher(t_id,t_name) –教师编号,教师姓名–4.成绩表Score(s_id,c_id,s_score) –学生编号,课程编号,分数 测试数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768--建表--学生表CREATE TABLE `Student`( `s_id` VARCHAR(20), `s_name` VARCHAR(20) NOT NULL DEFAULT '', `s_birth` VARCHAR(20) NOT NULL DEFAULT '', `s_sex` VARCHAR(10) NOT NULL DEFAULT '', PRIMARY KEY(`s_id`));--课程表CREATE TABLE `Course`( `c_id` VARCHAR(20), `c_name` VARCHAR(20) NOT NULL DEFAULT '', `t_id` VARCHAR(20) NOT NULL, PRIMARY KEY(`c_id`));--教师表CREATE TABLE `Teacher`( `t_id` VARCHAR(20), `t_name` VARCHAR(20) NOT NULL DEFAULT '', PRIMARY KEY(`t_id`));--成绩表CREATE TABLE `Score`( `s_id` VARCHAR(20), `c_id` VARCHAR(20), `s_score` INT(3), PRIMARY KEY(`s_id`,`c_id`));--插入学生表测试数据insert into Student values('01' , '赵雷' , '1990-01-01' , '男');insert into Student values('02' , '钱电' , '1990-12-21' , '男');insert into Student values('03' , '孙风' , '1990-05-20' , '男');insert into Student values('04' , '李云' , '1990-08-06' , '男');insert into Student values('05' , '周梅' , '1991-12-01' , '女');insert into Student values('06' , '吴兰' , '1992-03-01' , '女');insert into Student values('07' , '郑竹' , '1989-07-01' , '女');insert into Student values('08' , '王菊' , '1990-01-20' , '女');--课程表测试数据insert into Course values('01' , '语文' , '02');insert into Course values('02' , '数学' , '01');insert into Course values('03' , '英语' , '03');--教师表测试数据insert into Teacher values('01' , '张三');insert into Teacher values('02' , '李四');insert into Teacher values('03' , '王五');--成绩表测试数据insert into Score values('01' , '01' , 80);insert into Score values('01' , '02' , 90);insert into Score values('01' , '03' , 99);insert into Score values('02' , '01' , 70);insert into Score values('02' , '02' , 60);insert into Score values('02' , '03' , 80);insert into Score values('03' , '01' , 80);insert into Score values('03' , '02' , 80);insert into Score values('03' , '03' , 80);insert into Score values('04' , '01' , 50);insert into Score values('04' , '02' , 30);insert into Score values('04' , '03' , 20);insert into Score values('05' , '01' , 76);insert into Score values('05' , '02' , 87);insert into Score values('06' , '01' , 31);insert into Score values('06' , '03' , 34);insert into Score values('07' , '02' , 89);insert into Score values('07' , '03' , 98); 练习题和SQL语句123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242SELECT s.*, a.`s_score` AS 01score, b.`s_score` AS 02score FROM Student s INNER JOIN Score a ON s.`s_id` = a.`s_id` AND a.`c_id` = '01' INNER JOIN Score b ON s.`s_id` = b.`s_id` AND b.`c_id` = '02' WHERE a.`s_score` &gt; b.`s_score` -- 或者SELECT s.*, a.`s_score` AS 01score, b.`s_score` AS 02score FROM student s, score a, Score b WHERE s.s_id = a.s_id AND a.c_id = '01' AND s.s_id = b.s_id AND b.c_id = '02' AND a.s_score &gt; b.s_score -- 2、查询&quot;01&quot;课程比&quot;02&quot;课程成绩低的学生的信息及课程分数-- 3、查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩SELECT s.`s_id`, s.`s_name`, ROUND(AVG(a.`s_score`),2) AS avg_score FROM Student s INNER JOIN Score a ON s.`s_id` = a.`s_id` GROUP BY s.`s_id` HAVING AVG(a.`s_score`) &gt;= 60 -- 或者SELECT s.`s_id`, s.`s_name`, ROUND(AVG(a.`s_score`),2) AS avg_score FROM Student s, Score a WHERE s.`s_id` = a.`s_id` GROUP BY s.`s_id`HAVING AVG(a.`s_score`) &gt;= 60 -- 4、查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩 -- (包括有成绩的和无成绩的)SELECT s.`s_id`, s.`s_name`, ROUND(AVG(a.`s_score`),2) AS avg_score FROM Student s INNER JOIN Score a ON s.`s_id` = a.`s_id` GROUP BY s.`s_id` HAVING AVG(a.`s_score`) &gt;= 60 UNIONSELECT s.`s_id`, s.`s_name`, 0 AS avg_score FROM Student s WHERE s.`s_id` NOT IN(SELECT DISTINCT `s_id`FROM Score)-- 5、查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩SELECT a.`s_id` AS 编号, s.`s_name` AS 名字, COUNT(a.`c_id`) AS 选课总数, SUM(a.`s_score`) AS 总成绩 FROM Score a INNER JOIN Student s ON s.`s_id` = a.`s_id` GROUP BY a.`s_id` UNIONSELECT s.`s_id` AS 编号, s.`s_name` AS 名字, 0 AS 选课总数, 0 AS 总成绩 FROM Student sWHERE s.`s_id` NOT IN (SELECT DISTINCT a.`s_id`FROM Score a)SELECT s.`s_id` AS 编号, s.`s_name` AS 名字, COUNT(a.`c_id`) AS 选课总数, SUM(a.`s_score`) AS 总成绩 FROM Student s LEFT JOIN Score a ON s.`s_id` = a.`s_id` GROUP BY s.`s_id`-- 6、查询&quot;李&quot;姓老师的数量 SELECT COUNT(t.t_id) FROM Teacher t WHERE t.t_name LIKE '李%' -- 7、查询学过&quot;张三&quot;老师授课的同学的信息 SELECT s.* FROM Student s, Score a WHERE s.`s_id` = a.`s_id` AND a.`c_id` = (SELECT c.c_id FROM Teacher t, course c WHERE t.t_id = c.t_id AND t.t_name = '张三')-- 8、查询没学过&quot;张三&quot;老师授课的同学的信息 SELECT s.* FROMStudent sWHERE s.`s_id` NOT IN(SELECT s.`s_id` FROM Student s, Score a WHERE s.`s_id` = a.`s_id` AND a.`c_id` = (SELECT c.c_id FROM Teacher t, course c WHERE t.t_id = c.t_id AND t.t_name = '张三'))-- 9、查询学过编号为&quot;01&quot;并且也学过编号为&quot;02&quot;的课程的同学的信息SELECT s.* FROM Student s INNER JOIN Score a ON s.`s_id` = a.`s_id` AND a.`c_id` = '01' INNER JOIN Score b ON s.`s_id` = b.`s_id` AND b.`c_id` = '02' -- 10、查询学过编号为&quot;01&quot;但是没有学过编号为&quot;02&quot;的课程的同学的信息SELECT DISTINCT s.* FROM Student s INNER JOIN Score a ON s.`s_id` = a.`s_id` AND a.`c_id` = '01' INNER JOIN Score b ON s.`s_id` = b.`s_id` AND s.`s_id` NOT IN (SELECT DISTINCT s.`s_id` FROM Student s, Score a WHERE s.`s_id` = a.`s_id` AND a.`c_id` = '02')SELECT s.* FROM Student s WHERE s.`s_id` IN (SELECT a.`s_id` FROM Score a WHERE a.`c_id` = '01') AND s.`s_id` NOT IN (SELECT b.`s_id` FROM Score b WHERE b.`c_id` = '02')-- 12、查询至少有一门课与学号为&quot;01&quot;的同学所学相同的同学的信息 SELECT s.* FROM Student s WHERE s.`s_id` IN (SELECT DISTINCT a.`s_id` FROM Score a WHERE a.`c_id` IN (SELECT a.`c_id` FROM Score a WHERE a.`s_id` = '01'))-- 13、查询和&quot;01&quot;号的同学学习的课程完全相同的其他同学的信息SELECT s.* FROM score sc,student sWHERE s.`s_id` = sc.`s_id` AND s.`s_id`!='01' AND sc.s_id NOT IN(SELECT sc.s_id FROM score sc WHERE sc.c_idNOT IN(SELECT sc.c_id FROMscore sc WHERE sc.s_id = '01'))GROUP BY s.s_idHAVING COUNT(*) = (SELECT COUNT(c_id)FROM score WHERE s_id = '01')-- 1.查1号同学的课-- 2.查1号同学选的课以外的同学-- 3.把2的同学去除掉-- 4.用数量筛选一次-- 15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩SELECT s.s_id,s.`s_name`,ROUND(AVG(sc.`s_score`),2) FROMscore sc ,student sWHERE sc.s_score &lt;=60 AND s.s_id = sc.`s_id`GROUP BY s.`s_id`HAVING COUNT(s.`s_id`)&gt;=2-- 16、检索&quot;01&quot;课程分数小于60，按分数降序排列的学生信息SELECT s.*,sc.`c_id`,sc.`s_score`FROM score sc,student sWHERE sc.`c_id` = '01' AND sc.`s_score`&lt;=60 AND sc.`s_id` = s.`s_id`ORDER BY sc.`s_score` DESC","link":"/2021/10/12/sql%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/"},{"title":"vue基础知识","text":"vue 基础知识 vue-组件 父组件可以使用props把数据传给子组件 子组件可以使用$emit触发父组件的自定义方法 在vue中，使用props向子组件传值 子组件部分： 12345678910Vue.component('javaboy',{ data(){ return{ counter:0 } }, props:['title'], temoplate:'&lt;div&gt;&lt;button @click=&quot;counter++&quot;&gt;hello{{counter}} &lt;/button&gt;&lt;div&gt;{{title}} &lt;/div&gt;&lt;/div&gt;'}) 如果需要从父组件中获取台title的值，就需要使用props:[‘title’],在 props 中添加了元素之后，就不需要在 data 中再添加变量了. 父组件部分： 1234&lt;div&gt; &lt;javaboy :title=&quot;组件一&quot;&gt;&lt;/javaboy&gt; &lt;javaboy :title=&quot;组件二&quot;&gt;&lt;/javaboy&gt;&lt;/div&gt; 在调用组件的时候，使用v-bind 将 title的值要绑定data里面的变量，这里就直接赋值了，然后就可以将父组件的值传递给子组件了。 props是一个数组： 子组件： 1234567Vue.component('blog',{ props:['title','date','author'], template:'&lt;div&gt; &lt;div&gt;{{title}}&lt;/div&gt; &lt;div&gt;{{date}}--------{{author}}&lt;/div&gt; &lt;/div&gt;'}) 父组件： 123456789101112131415161718192021222324&lt;div&gt; &lt;blog v-for=&quot;(blog,index) in blogs :key=&quot;index&quot; :title=&quot;blog.title&quot; :date=&quot;blog.date&quot; :author=&quot;blog.author&quot; &quot;&gt;&lt;/blog&gt;&lt;/div&gt;data:{ blogs:[ { title:'标题一', date:'数据一', author:'作者一' }, { title:'标题二', date:'数据二', author:'作者二' }, { title:'标题三', date:'数据三', author:'作者三' },]} 子组件向父组件传值：主要是通过时间传递给父组件 子组件： 1234567891011121314&lt;template&gt; &lt;div class=&quot;sqs&quot;&gt; &lt;button @click=&quot;select(&quot;大连&quot;)&quot;&gt;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;methods:{ select(val){ let data = { cityName:val } this.$emit('showCityNmae',data)//select时间触发后，自动触发showCityNmae时间 }} 父组件： 12345678910&lt;div&gt; &lt;sqs @showCityNmae=&quot;updateCity&quot;&gt;&lt;/sqs&gt;&lt;/div&gt;methods:{ updateCity(data){//触发子组件城市选择-选择城市的事件 this.city = data.cityName//改变了父组件的值 console.log(city) }}","link":"/2021/10/12/vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"zookeeper","text":"Zookeeper zk-入门-特点 Zookeeper:一个领导者（Leader）,多个跟随者(Follower)组成的集群。 集群中只要有半数以上的节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。5台服务器挂了两台还剩下三台，可以正常使用，如果6台，挂了三台，还剩下三台，不能使用，浪费了一台。 全局数据一致：每个Server保存一分相同的数据副本，Client无论连接到哪个Server，数据都是一致的。 更新请求顺序执行，来自同一个Client的更新请求按其发送顺序一次执行。（先发送，先执行）。 数据更新原子性，一次数据更细要么成功，要么失败。（把他做成一个大的事务，每次写操作都有事务id——-zxid） 实时性，在一定时间范围内，Client能读到最新数据，如给Zookeeper集群中的一台服务器写了一个数据，其他服务器在短时间内，会同步更新的 zk-入门-数据结构 Zookeeper数据模型的结构与Unix文件系统和类似，整体上可以做是一个树，每个节点称作一个ZNode。每个ZNode默认能够存储1MB的数据，（所以zookeeper不能存储海量的数据），每个ZNode都可以通过其路径唯一标识 ​ 图 zk-入门-应用场景 zk-入门-下载地址 zk-入门-本地安装 jdk安装： 将jdk解压到opt目录下 1tar -zxvf jdk-8u311-linux-x64.tar.gz -C /opt 配置环境变量 vim /etc/profile 123456JAVA_HOME=/opt/jdk1.8.0_311PATH=$JAVA_HOME/bin:$PATHCLASSPATH=$JAVA_HOME/lib:.export JAVA_HOME PATH CLASSPATH source profile 让Linux重新加载这个配置文件 安装完成 安装zookeeper 下载地址http://zookeeper.apache.org/releases.html 选择3.5.7解压到opt目录，重命名 12mv apache-zookeeper-3.5.7-bin/ zookeeper-3.5.7-bin/ 先将zoo_sample.conf 重命名zoo.conf,然后将conf中的zoo_sample.conf 里面的dataDir换成自己zookeeper里面创建的zkData文件夹 12dataDir=/opt/zookeeper-3.5.7-bin/zkData 启动zookeeper服务端 1bin/zkServer.sh start 启动zookeeper客户端 1bin/skCli.sh 启动成功后输入命令 ls /查看节点 查看zookeeper的状态 1bin/zkServer.sh status 退出zookeeper客户端：quit 停止zookeepe服务端： 1bin/zkServer.sh stop zk-本地-配置参数解读 ticktime：通信心跳时间，zookeeper服务器与客户端心跳时间 initLimit：Leader和Follower初始通信时限 syncLimit：Leader和Follower同步通信时限 dataDir：保存zookeeper中的数据 注意：默认的tmp目录，容易被Linux系统定期删除，所以一般不用默认的tmp目录。 clientPort:客户端连接端口，通常不做修改 zk-集群-安装 在zkData目录下，vim一个文件==myid==，必须是这个名称。1号虚拟机为1,2号虚拟机为2 增加如下配置：zoo.cfg server.1=sqsLinux:2888:3888 server.2=sqsLinux02:2888:3888 配置参数解读： server.A=B:C:D A是一个数字，表示这是第几个服务器 ​ 集群模式下配置一个文件myid，这个文件在dataDir目录下，这个文件里面有个数据就是A的值，Zookeeper启动是时读取文件，拿到里面的数据与zoo.cfg里面的配置信息比较从而判断到底是哪个server。 B是这个服务器的地址 C是这个服务器Follower与集群中Leader服务器交换信息的端口； D是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。 集群完毕后，启动zookeeper报了个error？ 因为你没有启动半数以上的服务器，所以没有那个Leader， 这时启动第二台服务器，发现启动成功。==这个地方要是启动两台都是error，将防火墙关闭==service firewalld stop 两台都启动成功，查看2号服务器zookeeper状态是Leader，1号服务器是follower zk-集群-第一次启动选举机制（面试重点） 总共5台服务器 1号服务器启动，给自己一票，此时服务器票数不够半数以上，选举无法完成，1号服务器保持状态为looking 2号服务器启动，给自己一票，1号和2号交换选票信息，发现2号服务器的myid &gt; 1号服务器的myid，将自己的票给2号服务器，这时1号0票，2号2票。票数没有达到半数以上。选举无法完成。 3号服务器启动，给自己一票，2号3号交换选票信息。这时1号0票，2号0票，3号3票。票数达到半数以上，选举完成，3号为Leader。 4号服务器启动，给自己一票，只要集群中出现了Leader，其他自动变成follower。此时4号1票。 5号为1票。 SID:服务器id，用来表示zookeeper集群中机器的id，每台机器不能重复，和myid一致 ZXID：是一个事务id，用来标识一次服务器状态的变更。和zookeeper对于客户端 “更新请求” 的处理逻辑有关。 Epoch:每个Leader任期的代号 zk-集群-非第一次启动选举机制（面试重点） 当Zookeeper集群中的一台服务器出现以下两种情况之一时，就会开始进入Leader选举： 服务器初始化启动 服务器运行期间无法和Leader保持连接 当一台机器进入Leader选举流程时，当前集群可能会处于两种状态： 集群中已经有一个Leader，5号机器会试图去选举，会被告知Leader信息。对于5号机器来说，仅仅需要和Leader机器建立连接，并进行状态同步。 集群中 不存在Leader 现在有以下场景：zookeeper有5台服务器，SID 分别为1.2.3.4.5，ZXID分别为8.8.8.7.7，并且此时SID为3的服务器是Leader ，某一时刻，3和5服务器出现故障，因此需要开始进行Leader选举。 首选i，剩下1.2.4服务器超过半数以上，zookeeper集群可以使用。这时需要看三个参数（EPOCH,ZXID,SID） 1.2.4号服务器的投票情况（1,8,1），（1,8,2），（1,7,4） 选举Leader的规则：①Epoch大的胜出 ​ ②Epoch相同zxid大的胜出 ​ ③zxid相同，sid打的胜出 zk-集群-启动停止脚本 zk-客户端命令行-节点信息 正常打开zookeeper客户端会显示这个 12[zk: localhost:2181(CONNECTED) 0]会显示本地的 我们需要它显示自己的服务器IP地址 1bin/zkCli.sh -server sqsLinux:2181 节点信息图 zk-客户端命令行-节点类型 节点类型： 持久：客户端和服务器断开连接后，创建的节点不删除。 持久化节点不带序号：/znode1 持久化节点带序号：/znode2_001(这个顺序号是单调递增的计数器，由父节点来维护) 短暂：客户端和服务器断开连接后，创建的节点自己删除 有序号 无序号 创建永久节点，不带序号 12345create /sangguo &quot;diaochan&quot;ls /--&gt;[sangguo, zookeeper]create /sangguo/shuguo &quot;liubei&quot;ls /sangguo ---&gt;[shuguo] 获取节点里面的值 123456789101112131415get -s /sangguo----&gt;diaochancZxid = 0x300000006ctime = Sun Nov 21 16:49:19 CST 2021mZxid = 0x300000006mtime = Sun Nov 21 16:49:19 CST 2021pZxid = 0x300000007cversion = 1dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 8numChildren = 1----&gt; 创建带序号的节点 1create -s /sangguo/weiguo/zhangliao &quot;zhangliao&quot; 创建临时节点 1create -e /sangguo/wuguo &quot;zhouyu&quot; 创建临时节点带序号 1create -e -s /sangguo/wuguo &quot;zhouyu&quot; 修改节点数据值 1set /sangguo/weiguo &quot;simayi&quot; zk-客户端命令行-监听器及节点删除 监听原理详解： 首先要有一个线程 在main线程中创建Zookeeper客户端，这时就会创建两个线程，一个负责网络连接通信（connet),一个负责监听（listener）。 通过connet线程将注册的监听时间发送给Zookeeper 在zookeeper的注册监听器列表中将注册的监听事件添加到列表中 zookeeper监听到有数据或者路径变化，就会将这个消息发送给listener线程。 listener线程内部调用了process（）方法 常见的监听 监听节点数据的变化 1234get -w /sangguo//然后再另一台服务器上set /sangguo &quot;simayi&quot;//服务器就监听到了变化，第二次改变时，就监测不到变化了，只能监听一次 监听子节点增减的变化 1ls -w /sangguo 节点删除和查看 删除节点 1delete /sangguo/jin 递归删除节点 1deleteall /sangguo 查看节点状态 1stat /sangguo zk-客户端API-创建节点 初始化zookeeper 123456789//注意&quot;,&quot;左右不能有空格private String connectString = &quot;192.168.5.128:2181,192.168.5.131:2181&quot;;private int sessionTimeout = 200000;ZooKeeper zooKeeper = new ZooKeeper(connectString, sessionTimeout, new Watcher() { @Override public void process(WatchedEvent watchedEvent) { } }); 创建永久无序号节点 1String nodeCreated = zooKeeper.create(&quot;/atguigu&quot;, &quot;ss.avi&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); zk-客户端API-监听节点变化（这个地方没听懂） zk-客户端API-判断节点是否变化 数据节点是否存在 123456@Test public void exist() throws IOException, InterruptedException, KeeperException { ZooKeeper zkCli = init(); Stat stat = zkCli.exists(&quot;/atguigu&quot;, false); System.out.println(stat==null?&quot;not exist&quot;:&quot;exist&quot;); } zk-写数据原理 客户端直接访问Leader节点 客户端直接访问follower节点","link":"/2021/11/20/zookeeper/"},{"title":"总结问题","text":"工作中遇到的问题总结&lt;1&gt; 1.为什么GetMapping ,不使用@RequestBodyget请求： 1.请求参数是显示在请求行中 2.请求体是空的 3.请求参数会显示在地址栏中GET /?name=12a HTTP/1.1） 浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而@RequestBody是接受请求体中的数据 post请求： 1.请求参数不会显示在地址栏中 2.请求体是请求参数 3.请求参数不显示在请求首行中（POST/ HTTP/1.1） 浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据），并不是所有的浏览器都会在post上发送两次，Firefox就只会发送一次 2.@RequestParam和@RequestBody： @RequestBody –&gt; JSON字符串部分 @RequestParam –&gt; 请求参数部分 两种注解总结： @RequestBody 1234(@RequestBody Map map)(@RequestBody Object object)application/json时候可用form-data、x-www-form-urlencoded时候不可用 @RequestParam 123(@RequestParam Map map)application/json时候，json字符串部分不可用，url中的?后面添加参数即可用，见图一form-data、x-www-form-urlencoded时候可用，但是要将Headers里的Content-Type删掉 1234(@RequestParam String waterEleId,@RequestParam String enterpriseName)application/json时候，json字符串部分不可用，url中的?后面添加参数即可用，见图一form-data、x-www-form-urlencoded时候可用，且参数可以没有顺序（即前端传过来的参数或者url中的参数顺序不必和后台接口中的参数顺序一致，只要字段名相同就可以），但是要将Headers里的Content-Type删掉 12(@RequestParam Object object)不管application/json、form-data、x-www-form-urlencoded都不可用 既不是@RequestBody也不是@RequestParam，没有指定参数哪种接收方式 123456789(Map map)(Object object)application/json时候：json字符串部分不可用，url中的?后面添加参数不可用。因为没有指定，它也不知道到底是用json字符串部分还是?后面添加参数部分，所以干脆都不可以用form-data、x-www-form-urlencoded时都不可用，见图二(HttpServletRequest request)application/json不可用form-data、x-www-form-urlencoded时可用 3.Integer和int的区别 java两种数据类型： 基本数据类型，分为boolean、byte、int、char、long、short、double、float； 引用数据类型 ，分为数组、类、接口。 java为每个基本数据类型提供了封装类： 12基本数据类型: boolean，char，byte，short，int，long，float，double封装类类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 为什么不使用Integer而不使用int？ 1、 在MySQL中没有给字段赋值默认为null，当你从数据库中查出来也是null,如果该字段在对应的Java代码中是int类型，null不能对应int类型，因为int代表的是基本数据类型，只能是基本的数字。 2、实体类的属性你可以给它赋值也可以不给它赋值，当你不给它赋值时，它拥有默认值，比如int的默认值就为0。但是主动给它设置值为0与它默认为零是不同的概念。比如，一个班的成绩，0代表某学生分数为0，null代表这个学生该门考试没有成绩，这是两个不同的概念 int 和Integer的深入对比 ```javaInteger i = new Integer(100);Integer j = new Integer(100);System.out.print(i == j); //false 1234567+ Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，==java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较==） ```java Integer i = new Integer(100); int j = 100； System.out.print(i == j); //true 非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。因为非new生成的Integer变量指向的是静态常量池中cache数组中存储的指向了堆中的Integer对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的对象引用（地址）不同。 123Integer i = new Integer(100);Integer j = 100;System.out.print(i == j); //false 对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false 12345678Integer i = 100;Integer j = 100;System.out.print(i == j); //trueInteger i = 128;Integer j = 128;System.out.print(i == j); //false 自动拆箱和自动装箱 自动装箱：将基本数据类型重新转化为对象 1234567public class Test { public static void main(String[] args) { // 声明一个Integer对象，用到了自动的装箱：解析为:Integer num = Integer.valueOf(9); Integer num = 9; } } 9是属于基本数据类型的，原则上它是不能直接赋值给一个对象Integer的。但jdk1.5后你就可以进行这样的声明，自动将基本数据类型转化为对应的封装类型，成为一个对象以后就可以调用对象所声明的所有的方法。 自动拆箱：将对象重新转化为基本数据类型 123456789public class Test { public static void main(String[] args) { / /声明一个Integer对象 Integer num = 9; // 进行计算时隐含的有自动拆箱 System.out.print(num--); } } 12345// 装箱Integer num = 10;// 拆箱int num1 = num; 深入解析Integer 12345678910111213public class Test { public static void main(String[] args) { // 在-128~127 之外的数 Integer num1 = 128; Integer num2 = 128; System.out.println(num1==num2); //false // 在-128~127 之内的数 Integer num3 = 9; Integer num4 = 9; System.out.println(num3==num4); //true } } 解析原因：归结于java对于Integer与int的自动装箱与拆箱的设计，是一种模式：叫享元模式（flyweight）。（1）加大对简单数字的重利用，Java定义在自动装箱时对于在-128127之内的数值，它们被装箱为Integer对象后，会存在内存中被重用，始终只存在一个对象。（2）而如果在-128127之外的数，被装箱后的Integer对象并不会被重用，即相当于每次装箱时都新建一个 Integer对象 4.Servlet的声明周期5.get请求和post请求有什么区别 get（没有请求体） 提交请求参数，这个氢气参数会拼接在请求地址后面,以？号进行拼接，请求参数名=请求参数值 &amp; 请求参数名=请求参数值，其实就是表单元素，name=value。 get不安全 传输速度快 文件上传不能使用get，因为请求参数拼接在地址栏中，总不能把文件拼接在地址栏中吧，用get实现拼接的是文件名而不是文件 post（有请求体） 请求参数会放在请求体中，哪怕他把请求参数放在请求体中，格式也还是name=value post安全 传输速度慢 6. springMVC获取请求参数 通过servletApi获取 12345678@RequestMapping(&quot;/testServletApi&quot;)//形参位置的request表示当前请求public String testServletApi(HttpServletRequest req){ String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); System.out.println(&quot;username:&quot;+username + &quot;password:&quot;+password); return &quot;success&quot;;} 通过控制器的形参来接收请求参数 1234567@RequestMapping(&quot;/testParam&quot;) public String param(String username,String password,String[] hobby){ //若请求参数中国出现多个同名参数，可以在控制器方法的形参位置设置一个字符串类型或者字符号串数组做接收参数 //若使用字符串类型的形参，最终结果为请求参数的每一个值之间用逗号拼接的结果 System.out.println(&quot;username:&quot;+username + &quot;password:&quot;+password+ &quot;hobby:&quot;+ Arrays.toString(hobby)); return &quot;success&quot;; } 注意：形参参数名必须和请求参数名保持一致 @RequestParam @RequestHeader 因为请求头里面的悉心也是键值对形式，获取请求头里面的信息 @CookieValue 通过pojo获取请求参数 12345@RequestMapping(&quot;/testpojo&quot;) public String testpojo(User user){ System.out.println(user.toString()); return &quot;success&quot;; } 解决请求参数乱码的问题 get没有乱码 get乱码是因为tomcat的原因，将tomcat的配置文件server.xml，修改成 123&lt;Connector port=&quot;8080&quot; URIEncoding =&quot;UTF-8&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; post有乱码 12345678910/** * 这个地方post的编码问题 * 首先用HttpServletRequest req req.setEncoding= 为什么不行， * 因为servlet已经先接受了User的形参，然后你在使用req类设置就不行 * 那么就需要找到一个比servlet之前执行的东西，服务器执行顺序，监听器&gt;过滤器&gt;servlet * 监听器只是监听作用，就是监听servlet的创建和销毁， * 只要我们设置了过滤路径，只要当前访问地址满足了过滤路径，都会被过滤器过滤 * @param user * @return */ 123456789101112131415161718&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!--请求的编码--&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--响应的编码--&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 7.session和cookie8.服务器中的三大组件 监听器 过滤器 servlet 执行顺序监听器——&gt;过滤器——&gt;servlet 9.域对象共享 向request域中共享数据 使用servletAPI向request域对象共享对象 使用MOdelAndView向request 域对象共享数据 使用Model 使用ModelMap 使用Map 向session域中共享数据 ```java @RequestMapping(“/testSession”)public String testSession(HttpSession session){ session.setAttribute(&quot;testSessionScope&quot;,&quot;hello session&quot;); return &quot;success&quot;; } //thymeleaf 接收 session.testSessionScope12345678910+ 向application域共享数据 + ```java @RequestMapping(&quot;/testApplication&quot;) public String testApplication(HttpSession session){ ServletContext context = session.getServletContext(); context.setAttribute(&quot;testApplicationScope&quot;, &quot;hello application&quot;); return &quot;success&quot;; } 10.转发和重定向的区别 转发 浏览器发送一次请求 地址栏还是原来的地址 转发可以获取请求域中的数据 不能跨域 重定向 浏览器发送两次请求 第一次访问servlet 第二次访问重定向 地址栏是重定向后的地址 重定向不可以获取请求域中的数据 跨域跨域 11.主键生成策略 自动增长 auto_increament 优点： 缺点： 在分表的情况下，加入好多数据，需要多个表存，每个表存10000个数据，第一张表1-10000，第二个表需要获取第一个标的最后一个id+1生成第二个表。 UUID（随机的唯一的值） 优点： 在分表的时候，不需要获取上一个表的id值。 缺点： id值无法进行排序 Redis实现id 假如一个集群中5台Redis，每台机器的初始化1,2,3,4,5.使用redis的原子操作INCR 和INCRBY来实现。 A: 1,6,11,16,21 B:2,7,12,17,22 C:3,7,13,18,23 D:4,9,14,19,24 E:5,10,15,20,25 优点： 缺点： mp中自带策略（生成19位数字） 里面有个算法：Twitter的snowflake算法 里面的策略，在主键上面加上注解@Table(type=IdType.AUTO) AUTO:自动增长 ID_WORKER:mp自带，会生成19位的值，主键属性类型是Long类型。 ID_WORKER_STR:mp自带，主键类型是字符串类型。 INPUT:需要自己设置id值 NONE:需要自己输入 UUID:每次生成随机唯一值 12.自动填充 自动填充 表中添加两个字段 create_time,update_time 添加实体类属性 自己手动加时间 12user.setCreateTime(new Date());user.setUpdateTime(new Date()); 或者mp加时间 实现过程： 在实体类里面进行自动填充属性添加注解 1234@TableField(fill = FieldFill.INSERT)private Date createTime;@TableField(fill = FieldFill.INSERT_UPDATE)private Date updateTime; 创建类，实现接口MetaObjectHandler,实现接口里面的方法 12345678910111213@Component//交给spring接管public class MyMetaObjectHandler implements MetaObjectHandler { //使用mp实现添加操作，这个方法执行 @Override public void insertFill(MetaObject metaObject) { this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject); this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject); } //使用mp实现修改操作，这个方法执行 @Override public void updateFill(MetaObject metaObject) { this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject); } 13.乐观锁乐观锁：==解决某些问题== 主要解决：丢失更新 如果不考虑事务隔离性，产生读问题？脏读 不可重复度 幻读 写问题：丢失更新问题 丢失更新：举例子，有个工资条 id money 1 500 现有两个人A和B都去好这个工资 A——开始事务——500改成8000——首先提交8000——工资变成8000 B——开始事务——500改成200——之后提交——工资变成200，最后提交回覆盖之前的数据 丢失更新：多个人同时修改同一条记录，最后提交的把之前的提交数据覆盖 解决方案： 悲观锁：一个一个操作。A完成后B在操作，效率低 乐观锁 取出记录时，获取当前的version 更新时，带上这个version 执行更新时，set version = newVersion where version = oldVersion 如果version不对，就更新失败 乐观锁应用：抢票，谁都能抢到，但是谁先提交订单，谁就是抢到了 首先添加字段version 实体类中version属性添加version注解 写配置类（官网有） 123456789101112@Configuration@Componentpublic class MpConfig { /** * 乐观锁插件 */ @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor() { return new OptimisticLockerInterceptor(); }} 测试乐观锁 123456789@Testpublic void testOptimisticLocker(){ //现根据id查 User user = userMapper.selectById(1470062460986736642L); //进行修改 user.setAge(200); userMapper.updateById(user);} 14.使用mp做分页 写一个分页插件 12345678/** * 分页插件 * @return */@Beanpublic PaginationInterceptor paginationInterceptor(){ return new PaginationInterceptor();} 测试 1234567891011121314151617//分页@Testpublic void testPage(){ //传入两个参数 当前页，每页显示记录数 Page&lt;User&gt; page = new Page&lt;&gt;(1,3); //调用mp分页插查询的过程中，底层封装，把所有分页的数据封装到page对象里面 userMapper.selectPage(page, null); //通过page对象获取分页数据 System.out.println(&quot;当前页&quot;+page.getCurrent());// System.out.println(&quot;每页数据的List集合&quot;+page.getRecords()); System.out.println(&quot;总共有多少页&quot;+page.getPages()); System.out.println(&quot;每页放多少个数据&quot;+page.getSize()); System.out.println(&quot;总共多少条数据&quot;+page.getTotal()); System.out.println(&quot;是否有下页&quot;+page.hasNext()); System.out.println(&quot;是否有上页&quot;+page.hasPrevious());}","link":"/2021/11/03/%E6%80%BB%E7%BB%93%E9%97%AE%E9%A2%98/"},{"title":"Linux命令","text":"Linux 命令 Linux学习方式： 认识Linux 基本的命令（重点：Git讲了一些基本的命令（文件操作，目录管理，文件属性。vim编辑器，账号管理，磁盘管理。。。。）） 软件的安装和部署（java。Tomact。docker） 安装centos（在本地安装，不太建议，没有经济来源的，可以考虑在本地搭建） VMware下载（收费的，注册码） 可以通过镜像进行安装 可以使用我已经制作好的镜像 安装VMware虚拟机乳尖，然后打开我们的镜像可使用 在虚拟机上安装centos 狂神制作好的镜像（使用百度云下载即可） 1https://pan.baidu.com/s/1e0YEzN3BW0DDXFtMscvvVA ==Linux的目录结构== Linux只有一个根目录（Windows ： c d e f）。**==/==** 层级式的目录结构： 1.Linux的远程操作,用软件远程连接 Xshell:Linux的终端模拟软件（仅仅是模拟Linux，不能传文件） 安装并破解：解压，破解（运行两个.bat文件），启动 连接远程Linux系统，创立回话： ​ 查看Linux的IP地址：ifconfig Xftp:问价传输软件 安装并破解：解压 2.vi和vim是Linux的文本编辑器，用来在Linux中查看编辑，创建文本文件，就好像是记事本vi和vim的使用： ​ 三种模式: ​ 一般模式：用vi或者vim命令打开文件（==vim test.txt==），进入了一般模式 ​ 可以查看文件的内容，并且可以通过上下左右键来移动光标，查看文件某一部分； ​ 但是不能编辑文件内容 ​ 编辑模式：在一般模式下，==按i键或者a键==或者I键或者A键,进入编辑模式 ​ 可以编辑文件内容，不能保存内容。 ​ ==按ESC键==可以回到一般模式 ​ 命令模式：在一般模式下，==按：键==，进入命令模式 ​ 输入：q!———表示不保存，强制退出编辑器 ​ wq——–保存并退出 ​ q———-表示只是退出编辑器 vi和vim编辑器的快捷键： 复制当前行：在一般模式下，按yy，把光标所在行复制到剪切板 ​ 在一般模式下，按p把剪切板的内容粘贴到光标所在的下一行。 复制n行：在一般模式下，==按nyy== 在文件中查找关键字：在命令行模式下：==/关键字== 找到之后，按n表示贯标查找下一个关键字 删除光标所在的当前行，在一般模式下，按dd，删除光标的所在行 删除光标所在的行往下n行，在一般模式下按ndd 撤销上次编辑的内容，在一般模式下按u 显示行号：命令行模式：set nu set nonu 2.Linux的用户管理 任何使用Linux的系统资源的用户，必须有一个合法的账号和密码；账号和密码一般向系统管理员申请， root是Linux系统安装时默认创建的系统管理员账号，有root来创建普通账号。 ==添加用户==：useradd [选项]用户名 useradd lisi ​ |-&gt;创建一个指定用户lisi ​ |-&gt;在/home下创建lisi 的根目录， ​ |-&gt;还创建了一个组，组名就是lisi，（后面讲） useradd -d /home/ww wangwu(用的少，不好管理)，创建用户的同时，指定用户的根目录 ==给用户设置密码==:passwd 用户民 passwd lisi 密码要满足一定的复杂度 ==删除用户==：userdel 用户民 userdel lisi userdel -r lisi 删除用户的同时级联删除他的主目录 ==查看用户信息==：id 用户名 id lisi ==切换用户==：su 用户名 su zhangsan , 切换到高级用户会再次输入密码 3.组管理 1.==组管理==： Linux中的组相当于角色的概念，可以对有共性的用户进行统一管理 每一个用户至少属于一个组，不能独立于组存在，也可以属于多个组，新建用户时如果不指定组，则会新建一个组，组名和用户名相同，并把该用户添加到 2.==添加组：==groupadd 组名 ​ groupadd dev ==删除组==：groupdel 组名 groupdel dev ==把用户添加到组中==：gpasswd -a 用户名 组名 gpasswd -a sqs dev ==把用户从组中移除==： gpasswd -d 用户名 组名 ​ gpasswd -d sqs dev 6.==创建用户时指定所属的组（主组）==:useradd -g 组名 用户名 useradd -g dev lisi 4.linux 操作系统中的命令： 关机： shoutdown now 立即关机 shoutdown -h xxx 定时关机 shoutdown -r now 立即重启 重启：reboot 立即重启 同步数据库：sync 5.帮助命令： ==man==:用来查看Linux手册上的帮助信息 man 命令名称 man ls 分屏显示，按回车翻一行，按空格翻一屏，按q退出查看 ==help==：查看命令内置的帮助信息 help 命令 help cd 6.文件和目录操作命令 ==查看当前所在目录==：pwd pwd ==查看指定目录下的所有子目录或者文件列表ls==: ls [指定目录] ls /home ls -l /home(一列表形式) ls -a /home:显示指定目录下的所有子文件目录和文件（包括虚拟的目录） ls -al /home:一列表形式包括虚拟 ==切换目录==：cd 目录 绝对目录：以==盘符==开始的目录叫绝对目录 cd /opt/testDir ~：当前用户的根目录，在任何目录下执行cd ~ 进入当前用户的跟目录 相对目录：以目录名开始的目录叫相对目录 cd testDir (从当前目录往下找) ..： 当前目录的上一级目录 .: 当前目录 ==创建目录==：mkdir 目录名（一次只能创建一级目录，你要告诉他，才可以多级） 绝对目录 在/opt/testDir/目录下创建一个目录test1 : mkdir /opt/testDir/test1 相对目录 在opt/testDir 目录下创建一份目录test2 在opt/testDir 下创建目录test3，并在test3下创建test4 mkdir -p test3/test4 ==创建一个或多个空文件==:touch 文件名列表(文件名用空格隔开) touch t1.txt touch t2.txt t3.txt 删除一个空目录：rmdir 目录名 rmdir test1 ==复制文件==或者目录：cp [选项]source(源) dest(目标) 把test2目录复制到test3 中：不可以 ==cp -r test2 test3== ==删除文件或者mulu==:rm 文件名或目录名 rm t1.txt:提示删除文件 rm -f t2.txt：强制删除文件 rm test2 提示删除目录 rm -r（递归的意思） test2 提示删除目录 （得告诉他递归删除目录） rm -rf（递归的意思） test2 强制递归删除目录 ==移动文件或者目录==：mv source dest mv test.txt test1 mv test1 test2 mv t1.txt t2.txt //不可以，这是一个文件重命名 ==查看文件==：cat文件名 文件内容一次显现出来 cat t4.txt cat -n t4.txt 显示行号 ==分页查看文件内容==:more 文件名 一次性加载文件所有内容到内存，分页显示按回车翻一行，按住空格翻一页 more t4.txt ==分页查看文件内容==：less 文件名 分页加载文件所有内容到内存，分页显示 less t4.txt 按回车翻一行，按空格翻一页，按Q退出查看 ==查看问价你的头10行==：head[选项] 文件名 head t4.txt head -n 5 t4.txt ==查看文件的后10行==: tail [选项] 文件名 tail t4.txt tail -n 5 t4.txt ==echo==: 输入系统变量或者某个常量的值到命令行中断 echo $java_home echo hello ==&gt;指令==:把前一个命令的查看输出到指定文件中：查看命令 &gt; 文件名 如果目标文件不存在，则新建文件 如果目标文件存在，则把文件以前的内容覆盖 ls &gt; ret.txt ls -al ret.txt cat ret.txt &gt; t3.txt 文件内容复制 7.Linux中关于日期和时间的操作系统命令： 查看或设置系统的日期或者时间：date date 查看系统当前的完整的日期时间 date +%Y 系统当前的年份 date +%m 系统当前的月份 date +%d 系统当前的日期 date ‘+%Y-%m-%d %H:%M:%S’ 按yyyy-MM-dd HH:mm:ss 格式显示 date -s ‘2020-10-20 10:20:30‘ 设置当前系统时间 ==查看系统日历==： cal cal:查看当前月份日历 cal 2020:查看指定年份的日历 8. Linux中关于搜索文件或者目录的，命令：find[搜索范围][搜索标准] 关键字 ==find== -name:默认按照名称搜索(文件或者目录所在路径也在搜索范围之内) -size：按文件大小搜索 -user：按文件所有者搜索 find *.txt find *.txt find /etc *.txt 搜索指定目录下 find /etc -size +(- =)5M 搜索/etc目录下所有小于5k的 find /etc -user sqs locate（效率高）：在整颗目录树上搜索文件或者目录，都是根据名称搜索 updatedb :先同步 locate 关键字 索所有的。TXT updatedb locate *.txt ==搜索过滤命令==，在前一个搜索命令的结果中进行按名称进一步过滤： 搜索命令 |grep 过滤条件 查看命令 |grep(选项) 过滤条件 find *.txt |grep new 搜索当前目录下，所有名称包含new的.txt文件 find /etc -size -5k|grep firefox cat t1.txt|grep beijing cat t1.txt|grep -i beijing（i是忽略大小写） cat t1.txt|grep -in beijing（i是忽略大小写,可以显示行号） ls -al|grep new 9.linux中有关压缩和解压的命令： 压缩或者解压文件的命令（单个文件）: gzip 文件名；压缩单个文件，会生成.gz的压缩包，并且会把原来的文件删除。解压.gz压缩包，并且会把原来的.gz压缩包删除 gunzip：.gz压缩包名： 压缩（打包）或者解压文件的命令（多个文件）: zip 目标压缩包名称 文件或者目录列表 （通常使用.zip压缩包）: unzip :test.zip -d 指定解压目录名 压缩（打包）或者解压文件的命令（多个文件）: tar [选项]：目标压缩包名称（xxx.tar.gz） 文件或者目录列表 选项: -c:打包或者解压 tar [选项] 压缩包名（xxx.tar.gz） -C 报名 解压到当前目录，或者指定目录 -x:解压 tar-zcvf xxx.tar.gz 文件或者目录 tar-zxvf xxx.tar.gz -C解压目录 10文件或者目录与组： 在Linux中每一个用户都至少属于一个组，用户不能独立于组存在，一个用户属于多个组。 ​ 在Linux中每一个文件或者目录也必须属于一个组，而且只属于一个组; ​ 文件或者目录通过组来控制哪些用户可以对它进行哪些操作，即文件或者目录的访问权限 ​ 在文件或者目录看来，Linux把所有的用户分为3类： 所有者：默认情况下，文件或者目录的所有者都是创建者，可以修改。 同组用户：跟文件或者目录属于同一个组的用户 其他组用户：既不是文件或者目录的所有者，也不是同组用户 查看文件的所有者和所在的组： ls -l 修改文件或者目录的所有者：chown 新的所有者 文件名 ​ chown 新的所有者 ：新的组名 文件名 chown sqs t1.txt chown sqs ：dev t4.txt chown -R sqs ：dev t4.txt 递归的修改目录的所有者和所在的组 修改文件或者目录的所在组：chgrp 新的组名 文件名或者目录名 11文件或者权限管理 准备工作; 一个用户至少属于一个组，也可以属于多个组； 一个文件或者目录也必须属于一个组，并且只能属于一个组； 在一个文件或者目录看来，所有3类 所有者 同组 其他组 文件或者目录的3中权限: 在Linux中，任何文件或者目录都有3中权限：读（read）,写（write）,执行权限 对于文件而言： 读：可以读取查看文件内容， cat, more ,less ,head ,tail 写：可以修改文件的内容，如vi和vim 执行：如果改文件是可执行文件（.sh），可以直接运行，比如：./xxx.sh 对于目录而言 读：可以读取，查看目录下边的内容。比如：ls 写：可以修改你目录中的内容：创建子目录，删除子目录，，创建文件，删除文件 。重命名文件或目录 执行：可以进入该目录。比如：cd等 文件或者目录的权限控制： 在Linux系统中，任何一个文件或者目录都有三部分权限：所有者权限，同组用户权限，其他组用户权限 第一部分权限：所有者权限，文件或者目录的所有者对对改文件所拥有的权限，使用r w s分别表示读 写，执行的权限。比如：rwx:表示所有者对他拥有读写执行的权限，r-x:有读和执行的权限，r - –只有读的权限，- - - ，没有任何权限 ls -l 第二部分权限：同组用户权限，文件或者目录同组用户对该文件使用r w s分别表示读 写，执行的权限。 其他组权限：r w s分别表示读 写，执行的权限。 查看文件或者目录的权限： ls -aul 修改文件或者目录的权限：chmod 用 r w x 用 u,(所有者)，g(同组)，o(其他)，a（所有用户）修改权限 用 +， -，=分别表示指定的用户增加减少，设置对应的权限 chmod g-w,o+w t5.txt chmod g=rwx t5.txt chmod a-r t5.txt 使用数字非常的方式修改文件或者目录的权限： 每一个权限都可以用一个数字来表示： ​ r,w,x ​ 4,2,1 rw- r-x r-x 6 5 5 12网络配置 linux /etc/sysconfig/network-scripts BOOTPROTO=”static” ONBOOT=”yes” IPADDR=192.168.5.128GATEWAR=192.168.5.2DNS1=192.168.5.2 重启Linux：reboot 13进程管理 进程：一个程序的执行，一个进程占用一个端口 线程：一个程序的执行线路 查看正在运行进程：ps process status ps 只会显示应用进程 ps -e 显示所有进程 ps -ef 以全格式的形式显示所有进程 关闭进程： 使用kill -9 PID 14服务管理： 操作服务：systemctl 【start|stop|restart|reload|status|enable】 服务名称 systemctl status firewalld查看防火墙运行状态 systemctl stop firewalld关闭防火墙 systemctl start firewalld 开启防火墙 systemctl enable firewalld 设置防火墙开机启动 老版Linux使用service来操作服务 15管理软件包 RPM包： 一种Linux软件包的打包和安装工具，他操作的软件包都是。rpm结尾。 使用rpm：rpm命令 查看当前系统中已经安装 的rmp软件包: rpm -qa|firefox 卸载rpm软件包：rpm -e firefox 安装rpm包：rpm -ivh xxx.rpm 不在光驱中安装 ​ cp firefox-68.10.0-1.el7.centos.x86_64.rpm /opt ​ rpm -ivh firefox-68.10.0-1.el7.centos.x86_64.rpm YUM包管理：（得有外网） 是一种基于rpm的软件管路工具，有自己的服务器，自动下载rpm包下载，并且自动安装，可以自动处理软件包之间的依赖关系。 查看所有系统中已经安装的rpm包：yum list installed |grep firefox 卸载rpm软件包: yum remove firefox.x86_64 安装rpm包：yum install Firefox","link":"/2021/10/30/Linux%E5%91%BD%E4%BB%A4/"},{"title":"线程","text":"线程 线程1.什么是进程？什么是线程进程是一个应用程序（1个软件） 线程是一个进程中的执行场景/执行单元 一个进程可以启动多个线程 注意：进程A和进程B内存独立不共享， 在Java中 ==线程A和线程B，堆内存和方法区内存共享== ==但是栈内存独立，一个线程一个栈== 假设启动10个线程，会有10个栈空间，每个栈和每个栈之间互不干扰，各自执行各自的，这就是多线程并发 2.实现线程有三种方式2.1编写一个类，直接继承 Thread，重写run方法1234567891011121314151617181920212223242526272829package com.sen.demo01;/*实现线程第一种种方式 */public class ThreadDemo01 { public static void main(String[] args) { //新建一个分支线程对象 MyThread thread = new MyThread(); //启动线程 //start方法作用：启动一个分支线程，在JVM中开辟一个新的栈空间，这段代码任务完成后，瞬间就结束了 //这段代码只是为了开启一个新的栈空间，只要新的栈空间开辟出来，start方法就结束了，线程就启动成功了 //启动成功的线程会自动调用run方法，并且run方法在分支栈的栈空间底部（压栈） //run方法在分支栈的底部，main方法在主栈的底部。run和main是平级的 thread.start(); //这里的代码运行在主线程中 for (int i = 0; i &lt; 1000; i++) { System.out.println(&quot;主线程-----&gt;&quot;+i); } }}class MyThread extends Thread{ @Override public void run() { //编写程序，这段程序运行在分支线程 for (int i = 0; i &lt; 1000; i++) { System.out.println(&quot;分支线程-----&gt;&quot;+i); } }} 2.2第二种方法 编写一个类实现runnable接口，实现run方法(好，面向接口编程)1234567891011121314151617181920212223242526272829303132package com.sen.demo01;/*第二种方法 */public class ThreadDempo02 { public static void main(String[] args) { //创建一个可运行的对象 //MyRunnable r = new MyRunnable(); //将可运行的对象封装成线程类 //Thread t = new Thread(r); //合并 Thread t = new Thread(new MyRunnable()); t.start(); for (int i = 0; i &lt; 1000; i++) { System.out.println(&quot;主线程-----&gt;&quot;+i); } }}//这个目前还不是一个线程类，是一个可运行的类，class MyRunnable implements Runnable{ @Override public void run() { for (int i = 0; i &lt; 1000; i++) { System.out.println(&quot;分支线程------&gt;&quot;+i); } }} 采用匿名内部方式 123456789101112131415161718192021package com.sen.demo01;/*采用匿名内部类 */public class ThreadDemo03 { public static void main(String[] args) { Thread t = new Thread(new Runnable() { @Override public void run() { for (int i = 0; i &lt; 1000; i++) { System.out.println(&quot;分支线程----&gt;&quot;+i); } } }); t.start(); for (int i = 0; i &lt; 1000; i++) { System.out.println(&quot;主线程------&gt;&quot;+i); } }} 2.3第三种方式3获取线程对象 获取线程对象的名字 修改线程对象的名字123456789101112131415161718192021222324252627282930313233343536373839package com.sen.demo01;/*1.获取线程对象2.获取线程对象的名字3.修改线程对象的名字 */public class ThreadDemo04 { public static void main(String[] args) { //获取当前线程对象 //这个代码出现在main方法中，所以当前线程就是主线程 Thread currentThread = Thread.currentThread(); System.out.println(currentThread.getName());//main MyThread2 t = new MyThread2(); //给线程添加名字 t.setName(&quot;t1&quot;); //获取线程名字 t.getName(); System.out.println(t.getName());//Thread-0 MyThread2 t2 =new MyThread2(); t2.setName(&quot;t2&quot;); System.out.println(t2.getName());//Thread- t2.start(); t.start(); }}class MyThread2 extends Thread{ @Override public void run() { for (int i = 0; i &lt; 100; i++) { //谁执行run方法，当前线程就是谁 Thread currentThread = Thread.currentThread(); System.out.println(currentThread.getName()+&quot;---&gt; &quot; + i); } }} 4唤醒睡眠12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.sen.demo01;/*sleep睡眠太久了，如果希望半路醒来，也就是如何唤醒正在睡眠的线程 注意：这个不是中断线程的执行，是中止线程的睡眠 */public class ThreadDemo07 { public static void main(String[] args) { Thread t = new Thread(new MyRunnable2()); t.setName(&quot;t&quot;); t.start(); //希望5秒之后 t线程醒来 try { Thread.sleep(1000*5); } catch (InterruptedException e) { e.printStackTrace(); } //中断t线程睡眠 t.interrupt();//干扰，一盆冷水过去，考的是异常处理机制 }}class MyRunnable2 implements Runnable{ @Override //重点：run方法的异常不能throws，因为子类不能比父类抛出更多的异常 public void run() { System.out.println(Thread.currentThread().getName()+&quot;----&gt;begin&quot;); try { Thread.sleep(1000*60*24*365); } catch (InterruptedException e) { //打印异常信息 //注释掉，就不会打印了 // e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+&quot;----&gt;end&quot;); // doOther(); } /* //这个可以抛异常，因为子这个方法不是继承的 private void doOther() throws Exception{ } */} 5线程终止5.1 stop(不建议使用)1234567891011121314151617181920212223242526272829303132333435363738package com.sen.demo01;/*强行终止一个线程 */public class ThreadDemo08 { public static void main(String[] args) { Thread t = new Thread(new MyRunnable3()); t.setName(&quot;t&quot;); t.start(); //模拟5秒 try { Thread.sleep(1000*5); } catch (InterruptedException e) { e.printStackTrace(); } //5秒之后强行终止线程 //stop缺点：会丢失数据，是直接将线程杀死了，线程没有保存的数据容易丢失 t.stop();//已过时，不建议使用 }}class MyRunnable3 implements Runnable{ @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(Thread.currentThread().getName()+&quot;----&gt;&quot;+ i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }} 5.2打一个布尔标记(常用，要回)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.sen.demo01;/*合理终止一个线程的执行（很常用） */public class ThreadDemo09 { public static void main(String[] args) { MyRunnable4 r = new MyRunnable4(); Thread t = new Thread(r); t.setName(&quot;t&quot;); t.start(); //模拟5秒 try { Thread.sleep(1000*5); } catch (InterruptedException e) { e.printStackTrace(); } //终止线程 //你想要什么是终止T的执行，把标记改成false就OK了 r.run=false; }}class MyRunnable4 implements Runnable{ //打一个布尔 标记 boolean run=true; @Override public void run() { for (int i = 0; i &lt; 10; i++) { if (run){ System.out.println(Thread.currentThread().getName()+&quot;----&gt;&quot;+ i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } }else { //结束之前，还有没有保存的就可以保存了 //save...... //终止当前线程 return; } } }} 6常见的线程调度模式有哪些？6.1抢占式调度、那个线程的优先级比较高，抢到的CPU时间片的概率就高一些 Java就采用这种调度模式 6.2均分式模型平均分配CPU时间片，每个线程占有的CPU时间片时间长度一样，平均分配 一切平等 6.3Java中哪些方法300集 ==7关于多线程并发环境下，数据的安全问题== 什么时候会存在安全问题 三个条件： 多线程并发 有共享数据 共享数据有修改的行为 满足以上3个条件，就会存在线程安全问题 如何解决这个问题？ 用排队执行解决线程安全问题。 这种机制被称作：==线程同步机制==，会牺牲效率，没办法，数据安全第一位 同步编程模型： 线程t1和t2,在线程T1执行的，必须等T2，两个线程发生了等待关系， 排队关系 异步编程模型： 线程t1和t2，各自执行各自的，t1不管t2，t2不管t1，谁也不需要等谁其实就是多线程并发 ==异步就是并发，同步就是排队== 多线程同步机制 Account 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.sen.threadsafe2;/*银行账户 使用线程同步机制。解决线程安全问题 */public class Account { private String actno; private double balance; public Account() { } public Account(String actno, double balance) { this.actno = actno; this.balance = balance; } public String getActno() { return actno; } public void setActno(String actno) { this.actno = actno; } public double getBalance() { return balance; } public void setBalance(double balance) { this.balance = balance; } //取款方法 public void withdrow(double money){ //一下这几行代码必须是线程排队，不能并发 //一个线程把这里的代码全部执行结束之后，另一个线程才会进来 /* 线程同步机制的语法： synchronized (){ 同步代码块 } synchronized后面小括号里传的数据很重要 这个数据必须是多线程共享的数据，才能达到多线程排队 ()写什么 那要看你想让哪些线程同步 假设T1.T2,T3,T4,T5,有个线程 你只希望T1.T2,T3排队T4,T5不需要排队，怎么办？ 你一定要在（）中写一个T1.T2,T3共享的对象非，而这个对象对于 T4,T5来说不是共享的 这里的共享对象是：账户对象 那么this就是账户对象 不一定是this，只要是多线程共享对象就行 */ synchronized (this){ double before=this.getBalance(); double after=before-money; try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } this.setBalance(after); } }} AccountThread 1234567891011121314151617181920212223package com.sen.threadsafe2;import com.sen.threadsafe2.Account;public class AccountThread extends Thread{ //两个线程必须共享同一个账户对象 private Account act; //通过构造方法老传递账户对象 public AccountThread(Account act) { this.act=act; } @Override public void run() { //run 方法执行取款操作 //假设取款5000 double money=5000; act.withdrow(money); System.out.println(Thread.currentThread().getName()+&quot;对账户&quot;+act.getActno()+&quot;取款&quot;+money+&quot; 余额&quot;+act.getBalance()); System.out.println(&quot;================================&quot;); }} Test2 1234567891011121314151617181920package com.sen.threadsafe2;public class Test2 { public static void main(String[] args) { //只创建一个账户对象 Account act = new Account(&quot;act-001&quot;, 10000); //创建两个线程 AccountThread t1 = new AccountThread(act); AccountThread t2 = new AccountThread(act); //设置name t1.setName(&quot;t3&quot;); t2.setName(&quot;t4&quot;); t1.start(); t2.start(); }} 聊一聊在开发中应该怎么解决线程安全 是一上来就选择线程同步吗？synchronized ​ 不是，synchronized会使程序的效率较低，用户体验不好，系统用户的吞吐量降低，用户体验较低，在不得已的情况下在选择线程同步机制 尽量使用局部变量代替实例变量和静态变量 如果使用实例变量就要创建多个对象，这样实例变量的内存就不共享了，100个对象100个线程 如果不使用局部变量和创建多个对象，就只能synchronized，同步机制 了 8.java中三大变量实例变量：在堆中 静态变量：在方法区中 局部变量：在栈中 已上三大变量中： ​ 局部变量永远都不会存在线程安全问题 ​ 因为局部变量不共享（一个线程一个栈） ​ 局部变量在占中，所以不会 实力变量在堆中，堆只有一个 静态 变量在方法区中，方法区只有一个 堆和方法去都是多线程共享的，存在安全问题 9.synchronized三种写法9.1同步代码块灵活123synchronized(共享对象){ 同步代码块} 9.2在实力方法上使用synchronized，表示共享对象一定是this，并且同步代码块是整个方法体9.3在静态方法上使用synchronized，表示找类锁。类锁只有一把，就算创建了100个对象，那类锁也只有一把对象锁是一个对象一把锁 ，100个对象100把锁 9.4synchronized面试题112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.sen.exam;/*面试题：doother方法执行的时候需要等待dosome方法的结束吗 不需要 因为doother()没有 synchronized */public class Exam01 { public static void main(String[] args) throws InterruptedException { MyClass mc = new MyClass(); MyThread t1 = new MyThread(mc); MyThread t2 = new MyThread(mc); t1.setName(&quot;t1&quot;); t2.setName(&quot;t2&quot;); t1.start(); Thread.sleep(1000);//这个睡眠的作用：为了保证T1线程先执行 t2.start(); }}class MyThread extends Thread{ private MyClass mc; public void run(){ if (Thread.currentThread().getName().equals(&quot;t1&quot;)){ mc.dosome(); } if (Thread.currentThread().getName().equals(&quot;t2&quot;)){ mc.doother(); } } public MyThread(MyClass mc){ this.mc=mc; }}class MyClass{ public synchronized void dosome(){ System.out.println(&quot;dosome begin&quot;); try { Thread.sleep(1000*10); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;dosoem over&quot;); } public void doother(){ System.out.println(&quot;doother begin&quot;); System.out.println(&quot;doother over&quot;); }} 9.5面试题2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.sen.exam02;/*面试题：doother方法执行的时候需要等待dosome方法的结束吗 需要 */public class Exam01 { public static void main(String[] args) throws InterruptedException { MyClass mc = new MyClass(); MyThread t1 = new MyThread(mc); MyThread t2 = new MyThread(mc); t1.setName(&quot;t1&quot;); t2.setName(&quot;t2&quot;); t1.start(); Thread.sleep(1000);//这个睡眠的作用：为了保证T1线程先执行 t2.start(); }}class MyThread extends Thread{ private MyClass mc; public void run(){ if (Thread.currentThread().getName().equals(&quot;t1&quot;)){ mc.dosome(); } if (Thread.currentThread().getName().equals(&quot;t2&quot;)){ mc.doother(); } } public MyThread(MyClass mc){ this.mc=mc; }}class MyClass{ public synchronized void dosome(){ System.out.println(&quot;dosome begin&quot;); try { Thread.sleep(1000*10); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;dosoem over&quot;); } public synchronized void doother(){ System.out.println(&quot;doother begin&quot;); System.out.println(&quot;doother over&quot;); }} 9.6面试题31234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.sen.exma03;/*面试题：doother方法执行的时候需要等待dosome方法的结束吗 不需要 因为MyClass对象是2个，两把锁 */public class Exam01 { public static void main(String[] args) throws InterruptedException { MyClass mc1 = new MyClass(); MyClass mc2 = new MyClass(); MyThread t1 = new MyThread(mc1); MyThread t2 = new MyThread(mc2); t1.setName(&quot;t1&quot;); t2.setName(&quot;t2&quot;); t1.start(); Thread.sleep(1000);//这个睡眠的作用：为了保证T1线程先执行 t2.start(); }}class MyThread extends Thread{ private MyClass mc; public void run(){ if (Thread.currentThread().getName().equals(&quot;t1&quot;)){ mc.dosome(); } if (Thread.currentThread().getName().equals(&quot;t2&quot;)){ mc.doother(); } } public MyThread(MyClass mc){ this.mc=mc; }}class MyClass{ public synchronized void dosome(){ System.out.println(&quot;dosome begin&quot;); try { Thread.sleep(1000*10); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;dosoem over&quot;); } public synchronized void doother(){ System.out.println(&quot;doother begin&quot;); System.out.println(&quot;doother over&quot;); }} 9.7面试题4 ==需要 synchronized出现在静态方法上是类锁。因为静态方法是类锁，类锁不管创建了几个对象，类锁只有一把== 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.sen.exma04;/*面试题：doother方法执行的时候需要等待dosome方法的结束吗 需要 因为静态方法是类锁，类锁不管创建了几个对象，类锁只有一把 */public class Exam01 { public static void main(String[] args) throws InterruptedException { MyClass mc1 = new MyClass(); MyClass mc2 = new MyClass(); MyThread t1 = new MyThread(mc1); MyThread t2 = new MyThread(mc2); t1.setName(&quot;t1&quot;); t2.setName(&quot;t2&quot;); t1.start(); Thread.sleep(1000);//这个睡眠的作用：为了保证T1线程先执行 t2.start(); }}class MyThread extends Thread{ private MyClass mc; public void run(){ if (Thread.currentThread().getName().equals(&quot;t1&quot;)){ mc.dosome(); } if (Thread.currentThread().getName().equals(&quot;t2&quot;)){ mc.doother(); } } public MyThread(MyClass mc){ this.mc=mc; }}class MyClass{ //synchronized出现在静态方法上是类锁 public synchronized static void dosome(){ System.out.println(&quot;dosome begin&quot;); try { Thread.sleep(1000*10); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;dosoem over&quot;); } public synchronized static void doother(){ System.out.println(&quot;doother begin&quot;); System.out.println(&quot;doother over&quot;); }} 10死锁会写代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.sen.deadlock;/*死锁代码要会写，一般面试官要求你会写只有会写的，才会在以后的开发中注意这个事情因为死锁很难调试 */public class DeadLock { public static void main(String[] args) { Object o1 = new Object(); Object o2 = new Object(); Thread t1 = new MyThread1(o1,o2); Thread t2 = new MyThread1(o1,o2); t1.start(); t2.start(); }}class MyThread1 extends Thread{ Object o1; Object o2; public MyThread1(Object o1,Object o2){ } // synchronized 在开发中千万不要嵌套使用，指不定哪块死锁了 public void run(){ synchronized (o1){ synchronized (o2){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } }}class MyThread2 extends Thread{ Object o1; Object o2; public MyThread2(Object o1,Object o2){ } public void run(){ synchronized (o2){ synchronized (o1){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } }} 11守护线程123456789101112131415161718192021222324252627282930313233343536package com.sen.demo01;/*守护线程 */public class ThreadDemo10 { public static void main(String[] args) { Thread t =new BakDataThread(); t.setName(&quot;备份数据的线程&quot;); //启动线程之前，将线程设置为守护线程 t.setDaemon(true); t.start(); for (int i = 0; i &lt; 10; i++) { System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }}class BakDataThread extends Thread{ public void run(){ int i=0; //即使是守护线程，但由于该线程是守护线程，当用户线程结束，守护线程自动结束 while (true){ System.out.println(Thread.currentThread().getName()+&quot;----&gt;&quot;+(++i)); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }} 12定时器间隔特定的时间执行特定的程序 每周要进行银行账户的总账操作 每天要进行数据的备份操作 在实际的开发中，每隔多久执行一段特定的程序，这种需求是很常见的 在Java中，可以采用多中方式实现 ​ 可以使用sleep方法，没到这个时间段就醒来，这种方式是最原始的定时器（较low） 在Java类库中写好了一个定时器java.util.timer，可以直接拿来用，不过，这种方式也很大少用，因为好多高级框架都是支持定时器的 在实际的开发中，目前使用较多的spring中提供的springTask 框架，这个框架只需要进行简单的配置。就可以完成定时器的任务 12345678910111213141516171819202122232425262728293031323334package com.sen.demo01;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Formatter;import java.util.Timer;import java.util.TimerTask;/*使用定时器指定定时器任务 */public class timerDemo11 { public static void main(String[] args) throws Exception{ //创建定时器对象 Timer timer = new Timer(); //指定定时任务 SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date firsttime = format.parse(&quot;2021-03-20 16:43:00&quot;); timer.schedule(new LogTimerTask(),firsttime,1000*10); }}//编写一个定时器任务类//假设这是一个记录日志的定时任务class LogTimerTask extends TimerTask{ @Override public void run() { //编写任务 SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); String strtime = format.format(new Date()); System.out.println(strtime+&quot;:完成了一次数据备份&quot;); }} 13关于Object类中的wait和notify方法（生产者和消费者模式） wait和notify方法不是线程对象方法，是Java中任何一个对象都有的方法，因为这两个方式是object类中自带的 wait方法作用： ​ object o=new object（） o.wait 表示让正在o对象上活动的线程进入等待状态，无限期等待，直到被唤醒 wait方法调用会让当前线程进入等待 notify方法作用： notifyAll（）唤醒o对象上所有等待的线程 ==生产者消费者问题== 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.sen.demo01;import java.util.ArrayList;import java.util.List;/*1.使用wait和notify实现生产者和消费者模式2.什么是生产者和消费者模式 生产线程负责生产，消费线程负责消费 生产线程和消费线程要达到均衡 这是一种特殊的业务需求，在这种特殊的情况下使用wait和notify3.wait和notify方法不是线程对象的方法是普通Java对象方法4.wait和notify建立在线程同步的基础上，因为多线程要同时操作一个仓库，有线程安全问题5.wait： 表示让正在o对象上活动的线程进入等待状态，无限期等待，直到被唤醒，并且释放掉t线程之前占有的O对象的锁6.notify：唤醒正在o对象上等待的线程，只是通知，不会释放o对象上之前占有的锁7.模拟这样一个需求 仓库我们采用list集合 list集合中假设只能存储1个元素 1个元素就表示 仓库满了 如果list集合中元素的个数是0，就表示仓库空了 保证list集合中永远都是最多存储1个元素 必须做到这种效果：生产一个消费一个 */public class ThreadDemo13 { public static void main(String[] args) { //创建一个仓库对象，共享的 List list=new ArrayList(); //创建生产者线程 Thread t1 = new Thread(new Producer(list)); //创建消费者线程 Thread t2 = new Thread(new Consumer(list)); t1.setName(&quot;生产者线程&quot;); t2.setName(&quot;消费者线程&quot;); t1.start(); t2.start(); }}//生产线程class Producer implements Runnable{ //仓库 private List list; public Producer(List list) { this.list = list; } @Override public void run() { //一直生产(死循环来模拟一直生产) while (true){ //给仓库list对象枷锁 synchronized (list){ if (list.size()&gt;0) { try { //当前线程进入等待,并且释放Producer之前占有list集合的锁 list.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } //程序能够执行到这来说明仓库是空的，可以生产 Object obj = new Object(); list.add(obj); System.out.println(Thread.currentThread().getName()+&quot;生产----&gt;&quot;+obj); //唤醒消费者 list.notify(); } } }}//消费线程class Consumer implements Runnable{ private List list; public Consumer(List list) { this.list = list; } @Override public void run() { //一直消费 while (true){ synchronized (list){ if (list.size()==0){ try { //消费者线程等待，释放掉list集合的锁 list.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } //程序能够执行到此处，说明仓库有消费，进行消费 System.out.println(Thread.currentThread().getName()+&quot;消费---&gt;&quot;+list.get(0)); //若消费10个， //list.remove(list.size()-1); list.remove(0); //唤醒生产者 list.notify(); } } }} 作业 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.sen.demo01;import java.util.ArrayList;import java.util.List;/*使用生产者和消费者模式实现：交替输出： 假设有两个线程输出一下结果： t1---&gt;1 t2---&gt;2 t3---&gt;3 t4---&gt;4 */public class ThreadDemo14 { public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Thread t1 = new Thread(new Producer2(list)); Thread t2 = new Thread(new Consumer2(list)); t1.setName(&quot;t1&quot;); t2.setName(&quot;t2&quot;); t1.start(); t2.start(); }}//生产者线程class Producer2 implements Runnable{ private List&lt;Integer&gt; list; int i=1; public Producer2(List list) { this.list = list; } @Override public void run() { while (true){ synchronized (list){ //仓库满了，生产等待 if (list.size()&gt;0){ try { list.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } //仓库空了，需要生产 list.add(i); System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+list.get(0)); list.notify(); i+=2; } } }}//消费者线程class Consumer2 implements Runnable{ private List&lt;Integer&gt; list; public Consumer2(List list) { this.list = list; } @Override public void run() { while (true){ synchronized (list){ //仓库空了，消费等待 if (list.size()==0){ try { list.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } //返回的是&gt;0?吗，忘记了 Integer m = list.remove(0); m+=1; System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+m); //消费完成后，唤醒线程， list.notify(); } } }}","link":"/2021/10/30/%E7%BA%BF%E7%A8%8B/"},{"title":"springMvc","text":"SpringMVC 一、SpringMVC简1.什么是MVCmvc是一种架构思想 m:Model 模型层，指工程中的JavaBean JavaBean 分为两类 一种是实体类 指Service或者Dao对象 V：view，视图，html或者jsp C:controller，控制层，值工程中的servlet，作用是接收请求和响应浏览器。 2.什么是SpringMVC3. SpringMVC的特点二、Hello Worldwar包和jar包的区别 jar包是打成java 程序带运行环境 war包是web程序，将war发布到Tomcat的webapps目录下，Tomcat会在启东时自动解压war包。","link":"/2021/11/28/springMvc/"}],"tags":[{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"mybatis","slug":"mybatis","link":"/tags/mybatis/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"spring5","slug":"spring5","link":"/tags/spring5/"},{"name":"springcloud","slug":"springcloud","link":"/tags/springcloud/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"zookeeper","slug":"zookeeper","link":"/tags/zookeeper/"},{"name":"各种问题","slug":"各种问题","link":"/tags/%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"线程","slug":"线程","link":"/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/tags/SpringMVC/"}],"categories":[]}