{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/10/10/hello-world/"},{"title":"java-String类","text":"","link":"/2021/10/11/java-String%E7%B1%BB/"},{"title":"java-常用工具类","text":"java 常用工具类 一、util包下的常用类1.Collections常用方法： 12345678910111213public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c,T... elements)将所有指定元素添加到指定 collection 中。public static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list,T key)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定。public static &lt;T&gt; int binarySearch(List&lt;? extends T&gt; list,T key,Comparator&lt;? super T&gt; c)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且集合也事先必须是按照c比较器规则进行排序过的，否则结果不确定。public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，而且支持自然排序public static &lt;T&gt; T max(Collection&lt;? extends T&gt; coll,Comparator&lt;? super T&gt; comp)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，按照比较器comp找出最大者public static void reverse(List&lt;?&gt; list)反转指定列表List中元素的顺序。public static void shuffle(List&lt;?&gt; list) List 集合元素进行随机排序，类似洗牌public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)根据元素的自然顺序对指定 List 集合元素按升序排序public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; c)根据指定的 Comparator 产生的顺序对 List 集合元素进行排序public static void swap(List&lt;?&gt; list,int i,int j)将指定 list 集合中的 i 处元素和 j 处元素进行交换public static int frequency(Collection&lt;?&gt; c,Object o)返回指定集合中指定元素的出现次数public static &lt;T&gt; void copy(List&lt;? super T&gt; dest,List&lt;? extends T&gt; src)将src中的内容复制到dest中public static &lt;T&gt; boolean replaceAll(List&lt;T&gt; list，T oldVal，T newVal)：使用新值替换 List 对象的所有旧值public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)：返回指定列表支持的同步（线程安全的）列表public static &lt;T&gt; List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)返回指定列表的不可修改视图 1.1Comparator比较器排序，简单就是说比较两个对象之间的大小，在java中有两种比较方式，一个是实现java.lang.Comparable的接口，一种是实现java.util.Comparator的接口。 123456public int Comparator(String o1,String o2):比较两个参数的顺序两个对象比较的结果：&lt; &gt; =升序比较：o1 &gt; o2(正数) o1 &lt; o2 (负数)降序比较：o2 &gt; o1 (正数) o2 &lt; o1(负数) Demo: 123456789101112131415public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;abc&quot;); list.add(&quot;bac&quot;); list.add(&quot;cab&quot;); list.add(&quot;shb&quot;); Collections.sort(list,new Comparator&lt;String&gt;(){ //按照第一个单词降序 @Override public int compare(String o1, String o2) { return o2.charAt(0)-o1.charAt(0); } }); System.out.println(&quot;降序后的list:&quot;+list); } 1.2Comparable 和 Comparator的区别 Comparable: ​ 强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的 compaetTo 方法被称为她的自然比较方法。 只能在类中实现 compareTo() 一次，不能经常修改类的代码实现自己想要的排序，实现此接口的对象列表（和数组）可以通过 Collection.sort （和 Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无序指定比较器。 Comparator: ​ 强行对某个对象进行整体排序。可以将 Comparator 传递给 sort 方法（如Collection.sort 或 Array.sort），从而允许在排序上实现精确控制。 还可以使用 Comparator 来控制某些数据结构（如有序 set 或有序的映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。 Demo: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//Student类public class Student implements Comparable&lt;Student&gt; { private String name; private Integer age; public Student() { } public Student(String name, Integer age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + '}'; } @Override public int compareTo(Student o) { return this.age-o.age; }}//Testpublic static void main(String[] args) { List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student(&quot;sqs&quot;,24)); list.add(new Student(&quot;huang&quot;,22)); list.add(new Student(&quot;shihao&quot;,25)); list.add(new Student(&quot;zui&quot;,23)); /** * 让学生按照年龄升序 */ Collections.sort(list);//要求该list中元素类型，必须让该元素的类实现comparable接口 for (Student student : list) { System.out.println(student.toString()); } }-- 或者 public static void main(String[] args) { List&lt;Student1&gt; list = new ArrayList&lt;&gt;(); list.add(new Student1(&quot;sqs&quot;,22)); list.add(new Student1(&quot;huang&quot;,22)); list.add(new Student1(&quot;shihao&quot;,25)); list.add(new Student1(&quot;zui&quot;,23)); /** * 让学生按照年龄升序 */ Collections.sort(list, new Comparator&lt;Student1&gt;() { @Override public int compare(Student1 o1, Student1 o2) { //年龄排序 int result = o1.getAge()- o2.getAge(); if (result ==0 ){ //年龄一样，按照姓名首字符 result = o1.getName().charAt(0)-o2.getName().charAt(0); } return result; } }); for (Student1 student : list) { System.out.println(student.toString()); } } 总结：对于自定义的类型排序时，想要调用Collections.sort()或者Arrays.sort()时，必须指定一个比较器 在当前类中实现comparable接口，重写compareTo()方法，在里面指定比较方式 在调用sort（）方法时，在第二个参数的位置 new Comparator()对象，然后重写compare()方法 2.Calendar1234567891011121314151617181920212223242526272829public static void main(String[] args) { //获得一个Calendar的对象，是抽象类，无法new Calendar c = Calendar.getInstance(); //赋值时年月日时分秒常用的6个值。月份下标是从0开始 System.out.println(&quot;年&quot;+c.get(Calendar.YEAR)); System.out.println(&quot;月&quot;+c.get(Calendar.MONTH)+1); System.out.println(&quot;日&quot;+c.get(Calendar.DATE)); System.out.println(&quot;日&quot;+c.get(Calendar.DAY_OF_MONTH)); System.out.println(&quot;时&quot;+c.get(Calendar.HOUR_OF_DAY)); System.out.println(&quot;时&quot;+c.get(Calendar.HOUR)); System.out.println(&quot;分&quot;+c.get(Calendar.MINUTE)); System.out.println(&quot;秒&quot;+c.get(Calendar.SECOND)); //设置某个日期，可以一次设置年月日时分秒，也可以分开设置 c.set(2021,9,14,18,00); System.out.println(c.getTime()); //分开设置 c.set(Calendar.YEAR, 2018); c.set(Calendar.MONTH, Calendar.FEBRUARY); c.set(Calendar.DAY_OF_MONTH, 15); c.set(Calendar.HOUR_OF_DAY, 23); c.set(Calendar.MINUTE, 59); c.set(Calendar.SECOND, 59); System.out.println(c.getTime()); System.out.println(&quot;------&quot;); c.set(2018,0,31,0,0); c.add(Calendar.MONTH,1); System.out.println(c.getTime()); } 输出： 123456789101112131415年2021月91日14日14时14时2分16秒28Thu Oct 14 18:00:28 CST 2021Thu Feb 15 23:59:59 CST 2018------Wed Feb 28 00:00:59 CST 2018Process finished with exit code 0 3.日期操作类3.1Date1234567891011121314public static void main(String[] args) { Date date = new Date(); /** * Date 里面的无参构造调用了System.currentTimeMillis()回去了当前的时间 * public Date() { * this(System.currentTimeMillis()); * } * public Date(long date) { * fastTime = date; * } * */ System.out.println(date); } 从Date的构造方法中可以看出，Date类只是对long类型的一种包装，所以Date中一定存在日期与long类型转换的方法： 将long转换成Date:public Date(Loong date) 将Date换成long :public long getTime() 1234Date date = new Date();long current = date.getTime();current += 864000* 1000;//10天毫秒System.out.println(new Date(current)); long 之中存的毫秒，而不是秒，程序执行的都是以毫秒的量级 3.2SimpleDateFormat 将日期格式化：public final String format(Date date) 将字符串转为日期：public Date parse(String source) 构造方法：public SimpleDateFormat( String pattern) 1234567public static void main(String[] args) { Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;); String format = sdf.format(date); System.out.println(format); } 将字符串转换成Date 123456public static void main(String[] args) throws ParseException { String birthday = &quot;1998-12-12 16:11:11.111&quot;; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;); Date date = sdf.parse(birthday); System.out.println(date); } 4.UUID1UUID.randomUUID() 二、","link":"/2021/10/13/java-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"title":"springboot缓存","text":"springboot简单实现缓存 一、springboot + redis 加入两个依赖 cache redis application.properties 连接redis： 123spring.redis.host=redis的服务器IPspring.redis.password=密码spring.redis.port=6379 在启动类上加@EnableCache：开启缓存功能 4个注解 @Cacheable 1.@Cacheable(cacheNames = “c1”) :注解标注在方法上，表示该方法的返回值需要放到缓中 2.默认情况下，缓存的key是方法的参数 @EnableCaching:开启缓存功能 @CachePut:更新缓存 @CachePut(cacheNames= “c1”,key=“#user.id”) public User updateUser(User user){ ​ return user; } @CacheEvict:删除缓存 Demo1 1234567891011121314151617181920212223242526272829//User类//加入缓存，实现serializable 接口public class User implements Serializable { private String username; private Long id; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } @Override public String toString() { return &quot;User{&quot; + &quot;username='&quot; + username + '\\'' + &quot;, id=&quot; + id + '}'; } Service 类： 1234567891011public class UserService { @Cacheable(cacheNames = &quot;c1&quot;)//标记在方法上，表示该方法的返回值存到缓存中 //默认情况下，方法的参数作为缓存的key public User getUserByUserId(Long id){ System.out.println(&quot;getUserByUserId:&quot;+id); User user = new User(); user.setId(id); user.setName(&quot;sqs&quot;); return user; }} 测试结果： 123456789101112@Testvoid contextLoads(){ for(int i=0;i&lt;3;i++){ User u = userService.getUserById(98L); System.out.println(&quot;u=&quot;+u); }}输出结果：getUserById:98u=User{username='sqs',id=98}u=User{username='sqs',id=98}u=User{username='sqs',id=98} redis里面的存储情况： Demo2 12345678910111213141516171819202122232425//多个参数时，key的值是什么 /** * 默认情况下，方法的参数将作为缓存的key * 方法存在对个参数，则默认情况下，多个参数共同作为缓存的key * 1.通过key=“#参数名” 来指定缓存key * 2.也可以使用SPEL的表达式 * * @param id * @param username * @return */public User getUserById2(Long id,String name){ User user = new User(); user.setId(id); user.setName(name); return user;} @Testvoid contextLoads(){ User u1 = userService.getUserById2(99L,&quot;zhangsan&quot;); User u2 = userService.getUserById2(99L,&quot;zhangsan&quot;);}输出：getUserById2:99 //执行一次 默认情况下，方法的参数将作为缓存的key 方法存在对个参数，则默认情况下，多个参数共同作为缓存的key1.通过key=“#参数名” 来指定缓存key2.也可以使用SPEL的表达式 第一种方式指定key： 123456789101112指定key：# + 参数名， 只要id一样，那就可以从缓存中取@Cacheable(cacheNames = &quot;c2&quot;,key = &quot;#id&quot;) public User getUserById2(Long id,String name){}@Testvoid contextLoads(){ User u1 = userService.getUserById2(99L,&quot;zhangsan&quot;); User u2 = userService.getUserById2(99L,&quot;lisi&quot;);}输出结果： 代码没有错，getUserById2:99User{username='zhangsan', id=99} 逻辑有错误 第二种方式指定key：使用spel表达式 12345678@Cacheable(cacheNames = &quot;c2&quot;,key = &quot;#root.method.name&quot;) public User getUserById2(Long id,String name){}@Testvoid contextLoads(){ User u1 = userService.getUserById2(99L,&quot;zhangsan&quot;); User u2 = userService.getUserById2(99L,&quot;lisi&quot;);} 第三种指定key的方式：完全指定key 1234567891011//创建一个MyKeyGenerator类@Componentpublic class MyKeyGenerator implements KeyGenerator { @Override public Object generate(Object target, Method method, Object... params) { String s = target.toString() + &quot;:&quot; + method.getName() + &quot;:&quot; + Arrays.toString(params); return s; }} @Cacheable(cacheNames = &quot;c2&quot;,keyGenerator = &quot;myKeyGenerator&quot;)public User getUserById2(Long id,String name){} Demo3:缓存的更新 12345678910111213141516@CachePut(cacheNames = &quot;c1&quot;,key = &quot;#user.id&quot;)public User updateUser(User user){ return user}@Testvoid contextLoads(){ User u1 = userService.getUserById(100L); u1.setName(&quot;wangwu&quot;); userService.updateUser(u1); User u2 = userService. getUserById(100L); System.out.println(u2)}输出：getUserById:100User{username='wangwu', id=100} Demo4:删除缓存：默认先删除数据库，在删除缓存 ,beforeInvocation =true,是先删除缓存，后删库 12345678910111213141516@CacheEvict(cacheNames = &quot;c1&quot;,key=&quot;#id&quot;)public void deleteUserById(Long id){ sout(&quot;deleteUserById：&quot; + id);}@Testvoid contextLoads5(){ //上一步缓存中有user={id:100,username:wangwu} userService.deleteUserByTd(100L); User u = userService.getUserById(100L); System.out.println(u); }输出：deleteUserByTdgetUserById:100User{username='sqs', id=100} 二、springboot+ehcache","link":"/2021/10/15/springboot%E7%BC%93%E5%AD%98/"},{"title":"java-面向对象","text":"java 基础知识 多态多态：多态是同一个行为具有多个不同表现形式或形态的能力。 多态存在的单个必要条件 继承 重写 父类引用指向子类对象：Persion p = new Child() 贴一段代码来看一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Test { public static void main(String[] args) { Animal a1 = new Cat(); Animal a2 = new Dog(); show(a1); show(a2); Animal a = new Cat(); a.eat(); Cat c = (Cat) a; c.work(); } public static void show(Animal a){ a.eat(); //类型判断 if(a instanceof Cat){//猫做得事情 Cat c = (Cat) a; c.work(); } if (a instanceof Dog){//狗做得事情 Dog c = (Dog) a; c.work(); } }}abstract class Animal{ abstract void eat();}class Cat extends Animal{ public void eat() { System.out.println(&quot;吃鱼&quot;); } public void work(){ System.out.println(&quot;抓老鼠&quot;); }}class Dog extends Animal{ public void eat(){ System.out.println(&quot;吃骨头&quot;); } public void work(){ System.out.println(&quot;看家&quot;); }} 运行结果 123456吃鱼抓老鼠吃骨头看家吃鱼抓老鼠 抽象类抽象类：在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 由于抽象类不能实力化，所以抽象类必须被继承，才能被使用。 举个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243public abstract class Employee{ private String name; private String address; private int number; public Employee(String name, String address, int number) { System.out.println(&quot;Constructing an Employee&quot;); this.name = name; this.address = address; this.number = number; } public double computePay() { System.out.println(&quot;Inside Employee computePay&quot;); return 0.0; } public void mailCheck() { System.out.println(&quot;Mailing a check to &quot; + this.name + &quot; &quot; + this.address); } public String toString() { return name + &quot; &quot; + address + &quot; &quot; + number; } public String getName() { return name; } public String getAddress() { return address; } public void setAddress(String newAddress) { address = newAddress; } public int getNumber() { return number; }} 该类和普通的类没有区别，依然有3个变量，一个构造方法，7个成员方法，现在如下编译时，会产生错误， 1234567891011public class AbstractDemo{ public static void main(String [] args) { /* 以下是不允许的，会引发错误 */ Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43); System.out.println(&quot;\\n Call mailCheck using Employee reference--&quot;); e.mailCheck(); }} 报错： 1234Employee.java:46: Employee is abstract; cannot be instantiated Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43); ^1 error 所以通过继承Employee类，来使用Employee的属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Salary extends Employee{ private double salary; //Annual salary public Salary(String name, String address, int number, double salary) { super(name, address, number); setSalary(salary); } public void mailCheck() { System.out.println(&quot;Within mailCheck of Salary class &quot;); System.out.println(&quot;Mailing check to &quot; + getName() + &quot; with salary &quot; + salary); } public double getSalary() { return salary; } public void setSalary(double newSalary) { if(newSalary &gt;= 0.0) { salary = newSalary; } } public double computePay() { System.out.println(&quot;Computing salary pay for &quot; + getName()); return salary/52; }}public class AbstractDemo{ public static void main(String [] args) { Salary s = new Salary(&quot;Mohd Mohtashim&quot;, &quot;Ambehta, UP&quot;, 3, 3600.00); Employee e = new Salary(&quot;John Adams&quot;, &quot;Boston, MA&quot;, 2, 2400.00); System.out.println(&quot;Call mailCheck using Salary reference --&quot;); s.mailCheck(); System.out.println(&quot;\\n Call mailCheck using Employee reference--&quot;); e.mailCheck(); }} 编译结果如下： 123456789Constructing an EmployeeConstructing an EmployeeCall mailCheck using Salary reference --Within mailCheck of Salary classMailing check to Mohd Mohtashim with salary 3600.0Call mailCheck using Employee reference--Within mailCheck of Salary classMailing check to John Adams with salary 2400. 详设计一个类，该类有一个特别的成员方法，具体实现意由它的子类确定，那么可以在父类中声明该方法是抽象方法，抽象方法只有一个方法名，没有方法体。 1234567public abstract class Employee { private String name; private String address; private int number; public abstract double computePay(); //其他方法} 声明抽象方法会造成两个结果： 一个类包含抽象方法，该类一定是抽象类 任何子类必须重写父类的抽象方法，或者声明自身是抽象类，最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。 123456789101112public class Salary extends Employee{ private double salary; // Annual salary public double computePay() { System.out.println(&quot;Computing salary pay for &quot; + getName()); return salary/52; } //其余代码} 抽象类总结： 抽象类不嫩被实例化，只有继承抽象类的非抽象子类才可以实例化对象 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类 抽象类中的方法只是声明，没有方法体， 构造方法，类方法（用static修饰的方法） 不嫩声明为抽象方法 抽象类的子类必须给出抽象方法的具体实现，除非它也被声明为抽象类 接口接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。 接口和类的区别： 接口不能用于实例化对象 接口没有构造方法 接口中所有的方法必须是抽象方法 接口中不能包含成员变量，除了static和finally声明的成员变量 接口和抽象类的区别： 抽象类中可以有方法体，，接口不行 抽象类中的方法可以是任何类型的，接口只能是static和finall 接口以下特性： 接口是隐式抽象的，当声明一个接口时，不必使用abstract 接口中的方法也是隐式抽象的，不必使用abstract 接口中的方法都是public的","link":"/2021/10/11/java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"paperHelper插件","text":"","link":"/2021/10/14/paperHelper%E6%8F%92%E4%BB%B6/"},{"title":"sql语句练习","text":"SQL语句练习，习题来源于网络，SQL语句有部分参考。 表名和字段–1.学生表Student(s_id,s_name,s_birth,s_sex) –学生编号,学生姓名, 出生年月,学生性别–2.课程表Course(c_id,c_name,t_id) – –课程编号, 课程名称, 教师编号–3.教师表Teacher(t_id,t_name) –教师编号,教师姓名–4.成绩表Score(s_id,c_id,s_score) –学生编号,课程编号,分数 测试数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768--建表--学生表CREATE TABLE `Student`( `s_id` VARCHAR(20), `s_name` VARCHAR(20) NOT NULL DEFAULT '', `s_birth` VARCHAR(20) NOT NULL DEFAULT '', `s_sex` VARCHAR(10) NOT NULL DEFAULT '', PRIMARY KEY(`s_id`));--课程表CREATE TABLE `Course`( `c_id` VARCHAR(20), `c_name` VARCHAR(20) NOT NULL DEFAULT '', `t_id` VARCHAR(20) NOT NULL, PRIMARY KEY(`c_id`));--教师表CREATE TABLE `Teacher`( `t_id` VARCHAR(20), `t_name` VARCHAR(20) NOT NULL DEFAULT '', PRIMARY KEY(`t_id`));--成绩表CREATE TABLE `Score`( `s_id` VARCHAR(20), `c_id` VARCHAR(20), `s_score` INT(3), PRIMARY KEY(`s_id`,`c_id`));--插入学生表测试数据insert into Student values('01' , '赵雷' , '1990-01-01' , '男');insert into Student values('02' , '钱电' , '1990-12-21' , '男');insert into Student values('03' , '孙风' , '1990-05-20' , '男');insert into Student values('04' , '李云' , '1990-08-06' , '男');insert into Student values('05' , '周梅' , '1991-12-01' , '女');insert into Student values('06' , '吴兰' , '1992-03-01' , '女');insert into Student values('07' , '郑竹' , '1989-07-01' , '女');insert into Student values('08' , '王菊' , '1990-01-20' , '女');--课程表测试数据insert into Course values('01' , '语文' , '02');insert into Course values('02' , '数学' , '01');insert into Course values('03' , '英语' , '03');--教师表测试数据insert into Teacher values('01' , '张三');insert into Teacher values('02' , '李四');insert into Teacher values('03' , '王五');--成绩表测试数据insert into Score values('01' , '01' , 80);insert into Score values('01' , '02' , 90);insert into Score values('01' , '03' , 99);insert into Score values('02' , '01' , 70);insert into Score values('02' , '02' , 60);insert into Score values('02' , '03' , 80);insert into Score values('03' , '01' , 80);insert into Score values('03' , '02' , 80);insert into Score values('03' , '03' , 80);insert into Score values('04' , '01' , 50);insert into Score values('04' , '02' , 30);insert into Score values('04' , '03' , 20);insert into Score values('05' , '01' , 76);insert into Score values('05' , '02' , 87);insert into Score values('06' , '01' , 31);insert into Score values('06' , '03' , 34);insert into Score values('07' , '02' , 89);insert into Score values('07' , '03' , 98); 练习题和SQL语句123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242SELECT s.*, a.`s_score` AS 01score, b.`s_score` AS 02score FROM Student s INNER JOIN Score a ON s.`s_id` = a.`s_id` AND a.`c_id` = '01' INNER JOIN Score b ON s.`s_id` = b.`s_id` AND b.`c_id` = '02' WHERE a.`s_score` &gt; b.`s_score` -- 或者SELECT s.*, a.`s_score` AS 01score, b.`s_score` AS 02score FROM student s, score a, Score b WHERE s.s_id = a.s_id AND a.c_id = '01' AND s.s_id = b.s_id AND b.c_id = '02' AND a.s_score &gt; b.s_score -- 2、查询&quot;01&quot;课程比&quot;02&quot;课程成绩低的学生的信息及课程分数-- 3、查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩SELECT s.`s_id`, s.`s_name`, ROUND(AVG(a.`s_score`),2) AS avg_score FROM Student s INNER JOIN Score a ON s.`s_id` = a.`s_id` GROUP BY s.`s_id` HAVING AVG(a.`s_score`) &gt;= 60 -- 或者SELECT s.`s_id`, s.`s_name`, ROUND(AVG(a.`s_score`),2) AS avg_score FROM Student s, Score a WHERE s.`s_id` = a.`s_id` GROUP BY s.`s_id`HAVING AVG(a.`s_score`) &gt;= 60 -- 4、查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩 -- (包括有成绩的和无成绩的)SELECT s.`s_id`, s.`s_name`, ROUND(AVG(a.`s_score`),2) AS avg_score FROM Student s INNER JOIN Score a ON s.`s_id` = a.`s_id` GROUP BY s.`s_id` HAVING AVG(a.`s_score`) &gt;= 60 UNIONSELECT s.`s_id`, s.`s_name`, 0 AS avg_score FROM Student s WHERE s.`s_id` NOT IN(SELECT DISTINCT `s_id`FROM Score)-- 5、查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩SELECT a.`s_id` AS 编号, s.`s_name` AS 名字, COUNT(a.`c_id`) AS 选课总数, SUM(a.`s_score`) AS 总成绩 FROM Score a INNER JOIN Student s ON s.`s_id` = a.`s_id` GROUP BY a.`s_id` UNIONSELECT s.`s_id` AS 编号, s.`s_name` AS 名字, 0 AS 选课总数, 0 AS 总成绩 FROM Student sWHERE s.`s_id` NOT IN (SELECT DISTINCT a.`s_id`FROM Score a)SELECT s.`s_id` AS 编号, s.`s_name` AS 名字, COUNT(a.`c_id`) AS 选课总数, SUM(a.`s_score`) AS 总成绩 FROM Student s LEFT JOIN Score a ON s.`s_id` = a.`s_id` GROUP BY s.`s_id`-- 6、查询&quot;李&quot;姓老师的数量 SELECT COUNT(t.t_id) FROM Teacher t WHERE t.t_name LIKE '李%' -- 7、查询学过&quot;张三&quot;老师授课的同学的信息 SELECT s.* FROM Student s, Score a WHERE s.`s_id` = a.`s_id` AND a.`c_id` = (SELECT c.c_id FROM Teacher t, course c WHERE t.t_id = c.t_id AND t.t_name = '张三')-- 8、查询没学过&quot;张三&quot;老师授课的同学的信息 SELECT s.* FROMStudent sWHERE s.`s_id` NOT IN(SELECT s.`s_id` FROM Student s, Score a WHERE s.`s_id` = a.`s_id` AND a.`c_id` = (SELECT c.c_id FROM Teacher t, course c WHERE t.t_id = c.t_id AND t.t_name = '张三'))-- 9、查询学过编号为&quot;01&quot;并且也学过编号为&quot;02&quot;的课程的同学的信息SELECT s.* FROM Student s INNER JOIN Score a ON s.`s_id` = a.`s_id` AND a.`c_id` = '01' INNER JOIN Score b ON s.`s_id` = b.`s_id` AND b.`c_id` = '02' -- 10、查询学过编号为&quot;01&quot;但是没有学过编号为&quot;02&quot;的课程的同学的信息SELECT DISTINCT s.* FROM Student s INNER JOIN Score a ON s.`s_id` = a.`s_id` AND a.`c_id` = '01' INNER JOIN Score b ON s.`s_id` = b.`s_id` AND s.`s_id` NOT IN (SELECT DISTINCT s.`s_id` FROM Student s, Score a WHERE s.`s_id` = a.`s_id` AND a.`c_id` = '02')SELECT s.* FROM Student s WHERE s.`s_id` IN (SELECT a.`s_id` FROM Score a WHERE a.`c_id` = '01') AND s.`s_id` NOT IN (SELECT b.`s_id` FROM Score b WHERE b.`c_id` = '02')-- 12、查询至少有一门课与学号为&quot;01&quot;的同学所学相同的同学的信息 SELECT s.* FROM Student s WHERE s.`s_id` IN (SELECT DISTINCT a.`s_id` FROM Score a WHERE a.`c_id` IN (SELECT a.`c_id` FROM Score a WHERE a.`s_id` = '01'))-- 13、查询和&quot;01&quot;号的同学学习的课程完全相同的其他同学的信息SELECT s.* FROM score sc,student sWHERE s.`s_id` = sc.`s_id` AND s.`s_id`!='01' AND sc.s_id NOT IN(SELECT sc.s_id FROM score sc WHERE sc.c_idNOT IN(SELECT sc.c_id FROMscore sc WHERE sc.s_id = '01'))GROUP BY s.s_idHAVING COUNT(*) = (SELECT COUNT(c_id)FROM score WHERE s_id = '01')-- 1.查1号同学的课-- 2.查1号同学选的课以外的同学-- 3.把2的同学去除掉-- 4.用数量筛选一次-- 15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩SELECT s.s_id,s.`s_name`,ROUND(AVG(sc.`s_score`),2) FROMscore sc ,student sWHERE sc.s_score &lt;=60 AND s.s_id = sc.`s_id`GROUP BY s.`s_id`HAVING COUNT(s.`s_id`)&gt;=2-- 16、检索&quot;01&quot;课程分数小于60，按分数降序排列的学生信息SELECT s.*,sc.`c_id`,sc.`s_score`FROM score sc,student sWHERE sc.`c_id` = '01' AND sc.`s_score`&lt;=60 AND sc.`s_id` = s.`s_id`ORDER BY sc.`s_score` DESC","link":"/2021/10/12/sql%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/"},{"title":"vue基础知识","text":"vue 基础知识 vue-组件 父组件可以使用props把数据传给子组件 子组件可以使用$emit触发父组件的自定义方法 在vue中，使用props向子组件传值 子组件部分： 12345678910Vue.component('javaboy',{ data(){ return{ counter:0 } }, props:['title'], temoplate:'&lt;div&gt;&lt;button @click=&quot;counter++&quot;&gt;hello{{counter}} &lt;/button&gt;&lt;div&gt;{{title}} &lt;/div&gt;&lt;/div&gt;'}) 如果需要从父组件中获取台title的值，就需要使用props:[‘title’],在 props 中添加了元素之后，就不需要在 data 中再添加变量了. 父组件部分： 1234&lt;div&gt; &lt;javaboy :title=&quot;组件一&quot;&gt;&lt;/javaboy&gt; &lt;javaboy :title=&quot;组件二&quot;&gt;&lt;/javaboy&gt;&lt;/div&gt; 在调用组件的时候，使用v-bind 将 title的值要绑定data里面的变量，这里就直接赋值了，然后就可以将父组件的值传递给子组件了。 props是一个数组： 子组件： 1234567Vue.component('blog',{ props:['title','date','author'], template:'&lt;div&gt; &lt;div&gt;{{title}}&lt;/div&gt; &lt;div&gt;{{date}}--------{{author}}&lt;/div&gt; &lt;/div&gt;'}) 父组件： 123456789101112131415161718192021222324&lt;div&gt; &lt;blog v-for=&quot;(blog,index) in blogs :key=&quot;index&quot; :title=&quot;blog.title&quot; :date=&quot;blog.date&quot; :author=&quot;blog.author&quot; &quot;&gt;&lt;/blog&gt;&lt;/div&gt;data:{ blogs:[ { title:'标题一', date:'数据一', author:'作者一' }, { title:'标题二', date:'数据二', author:'作者二' }, { title:'标题三', date:'数据三', author:'作者三' },]} 子组件向父组件传值：主要是通过时间传递给父组件 子组件： 1234567891011121314&lt;template&gt; &lt;div class=&quot;sqs&quot;&gt; &lt;button @click=&quot;select(&quot;大连&quot;)&quot;&gt;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;methods:{ select(val){ let data = { cityName:val } this.$emit('showCityNmae',data)//select时间触发后，自动触发showCityNmae时间 }} 父组件： 12345678910&lt;div&gt; &lt;sqs @showCityNmae=&quot;updateCity&quot;&gt;&lt;/sqs&gt;&lt;/div&gt;methods:{ updateCity(data){//触发子组件城市选择-选择城市的事件 this.city = data.cityName//改变了父组件的值 console.log(city) }}","link":"/2021/10/12/vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"vue","slug":"vue","link":"/tags/vue/"}],"categories":[]}